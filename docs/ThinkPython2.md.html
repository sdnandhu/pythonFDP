<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ThinkPython2</title>
  <link rel="stylesheet" href="https://stackedit.io/style.css" />
</head>

<body class="stackedit">
  <div class="stackedit__left">
    <div class="stackedit__toc">
      
<ul>
<li>
<ul>
<li></li>
<li><a href="#chapter-13">Chapter 13</a></li>
</ul>
</li>
<li><a href="#case-study-data-structure">Case study: data structure</a></li>
<li><a href="#selection">selection</a>
<ul>
<li></li>
<li><a href="#chapter-14">Chapter 14</a></li>
</ul>
</li>
<li><a href="#files">Files</a>
<ul>
<li></li>
<li><a href="#chapter-15">Chapter 15</a></li>
</ul>
</li>
<li><a href="#classes-and-objects">Classes and objects</a>
<ul>
<li></li>
<li><a href="#chapter-16">Chapter 16</a></li>
</ul>
</li>
<li><a href="#classes-and-functions">Classes and functions</a>
<ul>
<li></li>
<li><a href="#chapter-17">Chapter 17</a></li>
</ul>
</li>
<li><a href="#classes-and-methods">Classes and methods</a>
<ul>
<li></li>
</ul>
</li>
<li><a href="#inside-class-time">inside class Time:</a>
<ul>
<li></li>
</ul>
</li>
<li><a href="#inside-class-time-1">inside class Time:</a>
<ul>
<li></li>
</ul>
</li>
<li><a href="#inside-class-time-2">inside class Time:</a>
<ul>
<li></li>
</ul>
</li>
<li><a href="#inside-class-time-3">inside class Time:</a>
<ul>
<li></li>
</ul>
</li>
<li><a href="#inside-class-time-4">inside class Time:</a>
<ul>
<li></li>
</ul>
</li>
<li><a href="#inside-class-time-5">inside class Time:</a></li>
<li><a href="#inside-class-time-6">inside class Time:</a>
<ul>
<li></li>
<li><a href="#chapter-18">Chapter 18</a></li>
</ul>
</li>
<li><a href="#inheritance">Inheritance</a>
<ul>
<li></li>
</ul>
</li>
<li><a href="#inside-class-card">inside class Card:</a>
<ul>
<li></li>
</ul>
</li>
<li><a href="#inside-class-card-1">inside class Card:</a></li>
<li><a href="#inside-class-card-2">inside class Card:</a>
<ul>
<li></li>
</ul>
</li>
<li><a href="#inside-class-deck">inside class Deck:</a>
<ul>
<li></li>
</ul>
</li>
<li><a href="#inside-class-hand">inside class Hand:</a>
<ul>
<li></li>
<li><a href="#chapter-19">Chapter 19</a></li>
</ul>
</li>
<li><a href="#case-study-tkinter">Case study: Tkinter</a>
<ul>
<li><a href="#gui">19.1 GUI</a></li>
<li><a href="#appendix-a">Appendix A</a></li>
</ul>
</li>
<li><a href="#debugging-7">Debugging</a>
<ul>
<li><a href="#a.1-syntax-errors">A.1 Syntax errors</a></li>
</ul>
</li>
<li><a href="#do-something-to-x">do something to x</a></li>
<li><a href="#do-something-to-y">do something to y</a>
<ul>
<li></li>
<li><a href="#appendix-b">Appendix B</a></li>
</ul>
</li>
<li><a href="#analysis-of-algorithms">Analysis of Algorithms</a>
<ul>
<li></li>
<li><a href="#appendix-c">Appendix C</a></li>
</ul>
</li>
<li><a href="#lumpy">Lumpy</a>
<ul>
<li><a href="#c.1-state-diagram">C.1 State diagram</a></li>
</ul>
</li>
</ul>

    </div>
  </div>
  <div class="stackedit__right">
    <div class="stackedit__html">
      <h3 id="exercises">12.11 Exercises</h3>
<p><strong>Exercise 12.3.</strong> Write a function calledmost_frequentthat takes a string and prints the let-<br>
ters in decreasing order of frequency. Find text samples from several different languages and see<br>
how letter frequency varies between languages. Compare your results with the tables at <a href="http://en.wikipedia.org/wiki/Letter_frequencies">http://en.wikipedia.org/wiki/Letter_frequencies</a><br>
Solution: <a href="http://thinkpython.com/code/most_frequent.py">http://thinkpython.com/code/most_frequent.py</a> .</p>
<p><strong>Exercise 12.4.</strong> More anagrams!</p>
<ol>
<li>Write a program that reads a word list from a file (see Section 9.1) and prints all the sets of<br>
words that are anagrams.<br>
Here is an example of what the output might look like:</li>
</ol>
<pre><code>['deltas','desalt','lasted', 'salted', 'slated','staled']
['retainers', 'ternaries']
['generating', 'greatening']
['resmelts','smelters','termless']
</code></pre>
<pre><code>Hint: you might want to build a dictionary that maps from a set of letters to a list of words
that can be spelled with those letters. The question is, how can you represent the set of letters
in a way that can be used as a key?
</code></pre>
<ol start="2">
<li>Modify the previous program so that it prints the largest set of anagrams first, followed by the<br>
second largest set, and so on.</li>
<li>In Scrabble a “bingo” is when you play all seven tiles in your rack, along with a letter on<br>
the board, to form an eight-letter word. What set of 8 letters forms the most possible bingos?<br>
Hint: there are seven.<br>
Solution:http: // thinkpython. com/ code/ anagram_ sets. py.</li>
</ol>
<p><strong>122 Chapter 12. Tuples</strong></p>
<p><strong>Exercise 12.5.</strong> Two words form a “metathesis pair” if you can transform one into the other by<br>
swapping two letters; for example, “converse” and “conserve.” Write a program that finds all of<br>
the metathesis pairs in the dictionary. Hint: don’t test all pairs of words, and don’t test all possible<br>
swaps. Solution:http: // thinkpython. com/ code/ metathesis. py. Credit: This exercise is<br>
inspired by an example athttp: // puzzlers. org.<br>
<strong>Exercise 12.6.</strong> Here’s another Car Talk Puzzler (http: // <a href="http://www.">http://www.</a> cartalk. com/ content/<br>
puzzlers):</p>
<pre><code>What is the longest English word, that remains a valid English word, as you remove its
letters one at a time?
Now, letters can be removed from either end, or the middle, but you can’t rearrange any
of the letters. Every time you drop a letter, you wind up with another English word. If
you do that, you’re eventually going to wind up with one letter and that too is going
to be an English word—one that’s found in the dictionary. I want to know what’s the
longest word and how many letters does it have?
I’m going to give you a little modest example: Sprite. Ok? You start off with sprite,
you take a letter off, one from the interior of the word, take the r away, and we’re left
with the word spite, then we take the e off the end, we’re left with spit, we take the s off,
we’re left with pit, it, and I.
</code></pre>
<p>Write a program to find all words that can be reduced in this way, and then find the longest one.</p>
<p>This exercise is a little more challenging than most, so here are some suggestions:</p>
<ol>
<li>You might want to write a function that takes a word and computes a list of all the words that<br>
can be formed by removing one letter. These are the “children” of the word.</li>
<li>Recursively, a word is reducible if any of its children are reducible. As a base case, you can<br>
consider the empty string reducible.</li>
<li>The wordlist I provided,words.txt, doesn’t contain single letter words. So you might want<br>
to add “I”, “a”, and the empty string.</li>
<li>To improve the performance of your program, you might want to memoize the words that are<br>
known to be reducible.</li>
</ol>
<p>Solution:http: // thinkpython. com/ code/ reducible. py.</p>
<h2 id="chapter-13">Chapter 13</h2>
<h1 id="case-study-data-structure">Case study: data structure</h1>
<h1 id="selection">selection</h1>
<h3 id="word-frequency-analysis">13.1 Word frequency analysis</h3>
<p>As usual, you should at least attempt the following exercises before you read my solutions.<br>
<strong>Exercise 13.1.</strong> Write a program that reads a file, breaks each line into words, strips whitespace and<br>
punctuation from the words, and converts them to lowercase.</p>
<p>Hint: Thestringmodule provides strings namedwhitespace, which contains space, tab, newline,<br>
etc., andpunctuationwhich contains the punctuation characters. Let’s see if we can make Python<br>
swear:</p>
<blockquote>
<blockquote>
<blockquote>
<p>import string<br>
print string.punctuation<br>
!"#$%&amp;’()*+,-./:;&lt;=&gt;?@[]^_`{|}~</p>
</blockquote>
</blockquote>
</blockquote>
<p>Also, you might consider using the string methodsstrip,replaceandtranslate.<br>
<strong>Exercise 13.2.</strong> Go to Project Gutenberg (http: // gutenberg. org) and download your favorite<br>
out-of-copyright book in plain text format.</p>
<p>Modify your program from the previous exercise to read the book you downloaded, skip over the<br>
header information at the beginning of the file, and process the rest of the words as before.</p>
<p>Then modify the program to count the total number of words in the book, and the number of times<br>
each word is used.</p>
<p>Print the number of different words used in the book. Compare different books by different authors,<br>
written in different eras. Which author uses the most extensive vocabulary?<br>
<strong>Exercise 13.3.</strong> Modify the program from the previous exercise to print the 20 most frequently-used<br>
words in the book.<br>
<strong>Exercise 13.4.</strong> Modify the previous program to read a word list (see Section 9.1) and then print all<br>
the words in the book that are not in the word list. How many of them are typos? How many of<br>
them are common words thatshouldbe in the word list, and how many of them are really obscure?</p>
<p><strong>124 Chapter 13. Case study: data structure selection</strong></p>
<h3 id="random-numbers">13.2 Random numbers</h3>
<p>Given the same inputs, most computer programs generate the same outputs every time,<br>
so they are said to be <strong>deterministic</strong>. Determinism is usually a good thing, since we expect<br>
the same calculation to yield the same result. For some applications, though, we want the<br>
computer to be unpredictable. Games are an obvious example, but there are more.</p>
<p>Making a program truly nondeterministic turns out to be not so easy, but there are ways<br>
to make it at least seem nondeterministic. One of them is to use algorithms that generate<br>
<strong>pseudorandom</strong> numbers. Pseudorandom numbers are not truly random because they are<br>
generated by a deterministic computation, but just by looking at the numbers it is all but<br>
impossible to distinguish them from random.</p>
<p>Therandommodule provides functions that generate pseudorandom numbers (which I<br>
will simply call “random” from here on).</p>
<p>The functionrandomreturns a random float between 0.0 and 1.0 (including 0.0 but not 1.0).<br>
Each time you callrandom, you get the next number in a long series. To see a sample, run<br>
this loop:</p>
<p>import random</p>
<p>for i in range(10):<br>
x = random.random()<br>
print x</p>
<p>The functionrandinttakes parameterslowandhighand returns an integer betweenlow<br>
andhigh(including both).</p>
<blockquote>
<blockquote>
<blockquote>
<p>random.randint(5, 10)<br>
5</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>random.randint(5, 10)<br>
9</p>
</blockquote>
</blockquote>
</blockquote>
<p>To choose an element from a sequence at random, you can usechoice:</p>
<blockquote>
<blockquote>
<blockquote>
<p>t = [1, 2, 3]<br>
random.choice(t)<br>
2</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>random.choice(t)<br>
3</p>
</blockquote>
</blockquote>
</blockquote>
<p>Therandommodule also provides functions to generate random values from continuous<br>
distributions including Gaussian, exponential, gamma, and a few more.<br>
<strong>Exercise 13.5.</strong> Write a function namedchoose_from_histthat takes a histogram as defined in<br>
Section 11.1 and returns a random value from the histogram, chosen with probability in proportion<br>
to frequency. For example, for this histogram:</p>
<blockquote>
<blockquote>
<blockquote>
<p>t = [‘a’, ‘a’, ‘b’]<br>
hist = histogram(t)<br>
print hist<br>
{‘a’: 2,‘b’: 1}</p>
</blockquote>
</blockquote>
</blockquote>
<p>your function should return’a’with probability2/3and’b’with probability1/3.</p>
<p><strong>13.3. Word histogram 125</strong></p>
<h3 id="word-histogram">13.3 Word histogram</h3>
<p>You should attempt the previous exercises before you go on. You can download my so-<br>
lution fromhttp://thinkpython.com/code/analyze_book.py. You will also needhttp:<br>
<a href="//thinkpython.com/code/emma.txt">//thinkpython.com/code/emma.txt</a>.</p>
<p>Here is a program that reads a file and builds a histogram of the words in the file:</p>
<p>import string</p>
<p>def process_file(filename):<br>
hist = dict()<br>
fp = open(filename)<br>
for line in fp:<br>
process_line(line, hist)<br>
return hist</p>
<p>def process_line(line, hist):<br>
line = line.replace(’-’,’’)</p>
<pre><code>for word in line.split():
word = word.strip(string.punctuation + string.whitespace)
word = word.lower()
</code></pre>
<pre><code>hist[word] = hist.get(word, 0) + 1
</code></pre>
<p>hist = process_file(‘emma.txt’)</p>
<p>This program readsemma.txt, which contains the text ofEmmaby Jane Austen.</p>
<p>process_fileloops through the lines of the file, passing them one at a time to<br>
process_line. The histogramhistis being used as an accumulator.</p>
<p>process_lineuses the string methodreplaceto replace hyphens with spaces before using<br>
splitto break the line into a list of strings. It traverses the list of words and usesstrip<br>
andlowerto remove punctuation and convert to lower case. (It is a shorthand to say that<br>
strings are “converted;” remember that string are immutable, so methods likestripand<br>
lowerreturn new strings.)</p>
<p>Finally,process_lineupdates the histogram by creating a new item or incrementing an<br>
existing one.</p>
<p>To count the total number of words in the file, we can add up the frequencies in the his-<br>
togram:</p>
<p>def total_words(hist):<br>
return sum(hist.values())</p>
<p>The number of different words is just the number of items in the dictionary:</p>
<p>def different_words(hist):<br>
return len(hist)</p>
<p>Here is some code to print the results:</p>
<p>print’Total number of words:’, total_words(hist)<br>
print’Number of different words:’, different_words(hist)</p>
<p><strong>126 Chapter 13. Case study: data structure selection</strong></p>
<p>And the results:</p>
<p>Total number of words: 161080<br>
Number of different words: 7214</p>
<h3 id="most-common-words">13.4 Most common words</h3>
<p>To find the most common words, we can apply the DSU pattern;most_commontakes a<br>
histogram and returns a list of word-frequency tuples, sorted in reverse order by frequency:</p>
<p>def most_common(hist):<br>
t = []<br>
for key, value in hist.items():<br>
t.append((value, key))</p>
<pre><code>t.sort(reverse=True)
return t
</code></pre>
<p>Here is a loop that prints the ten most common words:</p>
<p>t = most_common(hist)<br>
print ‘The most common words are:’<br>
for freq, word in t[0:10]:<br>
print word,’\t’, freq</p>
<p>And here are the results fromEmma:</p>
<p>The most common words are:<br>
to 5242<br>
the 5205<br>
and 4897<br>
of 4295<br>
i 3191<br>
a 3130<br>
it 2529<br>
her 2483<br>
was 2400<br>
she 2364</p>
<h3 id="optional-parameters">13.5 Optional parameters</h3>
<p>We have seen built-in functions and methods that take a variable number of arguments. It<br>
is possible to write user-defined functions with optional arguments, too. For example, here<br>
is a function that prints the most common words in a histogram</p>
<p>def print_most_common(hist, num=10):<br>
t = most_common(hist)<br>
print ‘The most common words are:’<br>
for freq, word in t[:num]:<br>
print word,’\t’, freq</p>
<p>The first parameter is required; the second is optional. The <strong>default value</strong> ofnumis 10.</p>
<p>If you only provide one argument:</p>
<p><strong>13.6. Dictionary subtraction 127</strong></p>
<p>print_most_common(hist)</p>
<p>numgets the default value. If you provide two arguments:</p>
<p>print_most_common(hist, 20)</p>
<p>numgets the value of the argument instead. In other words, the optional argument <strong>over-<br>
rides</strong> the default value.</p>
<p>If a function has both required and optional parameters, all the required parameters have<br>
to come first, followed by the optional ones.</p>
<h3 id="dictionary-subtraction">13.6 Dictionary subtraction</h3>
<p>Finding the words from the book that are not in the word list fromwords.txtis a problem<br>
you might recognize as set subtraction; that is, we want to find all the words from one set<br>
(the words in the book) that are not in another set (the words in the list).</p>
<p>subtracttakes dictionariesd1andd2and returns a new dictionary that contains all the<br>
keys fromd1that are not ind2. Since we don’t really care about the values, we set them all<br>
to None.</p>
<p>def subtract(d1, d2):<br>
res = dict()<br>
for key in d1:<br>
if key not in d2:<br>
res[key] = None<br>
return res</p>
<p>To find the words in the book that are not inwords.txt, we can useprocess_fileto build<br>
a histogram forwords.txt, and then subtract:</p>
<p>words = process_file(‘words.txt’)<br>
diff = subtract(hist, words)</p>
<p>print “The words in the book that aren’t in the word list are:”<br>
for word in diff.keys():<br>
print word,</p>
<p>Here are some of the results fromEmma:</p>
<p>The words in the book that aren’t in the word list are:<br>
rencontre jane’s blanche woodhouses disingenuousness<br>
friend’s venice apartment …</p>
<p>Some of these words are names and possessives. Others, like “rencontre,” are no longer in<br>
common use. But a few are common words that should really be in the list!<br>
<strong>Exercise 13.6.</strong> Python provides a data structure calledsetthat provides many common set opera-<br>
tions. Read the documentation athttp: // docs. python. org/ 2/ library/ stdtypes. html#<br>
types- setand write a program that uses set subtraction to find words in the book that are not in<br>
the word list. Solution:http: // thinkpython. com/ code/ analyze_ book2. py.</p>
<h3 id="random-words">13.7 Random words</h3>
<p>To choose a random word from the histogram, the simplest algorithm is to build a list with<br>
multiple copies of each word, according to the observed frequency, and then choose from<br>
the list:</p>
<p><strong>128 Chapter 13. Case study: data structure selection</strong></p>
<p>def random_word(h):<br>
t = []<br>
for word, freq in h.items():<br>
t.extend([word] * freq)</p>
<pre><code>return random.choice(t)
</code></pre>
<p>The expression[word] * freqcreates a list withfreqcopies of the stringword. The<br>
extendmethod is similar toappendexcept that the argument is a sequence.<br>
<strong>Exercise 13.7.</strong> This algorithm works, but it is not very efficient; each time you choose a random<br>
word, it rebuilds the list, which is as big as the original book. An obvious improvement is to build<br>
the list once and then make multiple selections, but the list is still big.</p>
<p>An alternative is:</p>
<ol>
<li>Usekeysto get a list of the words in the book.</li>
<li>Build a list that contains the cumulative sum of the word frequencies (see Exercise 10.3). The<br>
last item in this list is the total number of words in the book, n.</li>
<li>Choose a random number from 1 to n. Use a bisection search (See Exercise 10.11) to find the<br>
index where the random number would be inserted in the cumulative sum.</li>
<li>Use the index to find the corresponding word in the word list.</li>
</ol>
<p>Write a program that uses this algorithm to choose a random word from the book. Solution:http:<br>
// thinkpython. com/ code/ analyze_ book3. py.</p>
<h3 id="markov-analysis">13.8 Markov analysis</h3>
<p>If you choose words from the book at random, you can get a sense of the vocabulary, you<br>
probably won’t get a sentence:</p>
<p>this the small regard harriet which knightley’s it most things</p>
<p>A series of random words seldom makes sense because there is no relationship between<br>
successive words. For example, in a real sentence you would expect an article like “the” to<br>
be followed by an adjective or a noun, and probably not a verb or adverb.</p>
<p>One way to measure these kinds of relationships is Markov analysis, which characterizes,<br>
for a given sequence of words, the probability of the word that comes next. For example,<br>
the songEric, the Half a Beebegins:</p>
<pre><code>Half a bee, philosophically,
Must, ipso facto, half not be.
But half the bee has got to be
Vis a vis, its entity. D’you see?
</code></pre>
<pre><code>But can a bee be said to be
Or not to be an entire bee
When half the bee is not a bee
Due to some ancient injury?
</code></pre>
<p><strong>13.9. Data structures 129</strong></p>
<p>In this text, the phrase “half the” is always followed by the word “bee,” but the phrase “the<br>
bee” might be followed by either “has” or “is”.</p>
<p>The result of Markov analysis is a mapping from each prefix (like “half the” and “the bee”)<br>
to all possible suffixes (like “has” and “is”).</p>
<p>Given this mapping, you can generate a random text by starting with any prefix and choos-<br>
ing at random from the possible suffixes. Next, you can combine the end of the prefix and<br>
the new suffix to form the next prefix, and repeat.</p>
<p>For example, if you start with the prefix “Half a,” then the next word has to be “bee,”<br>
because the prefix only appears once in the text. The next prefix is “a bee,” so the next<br>
suffix might be “philosophically,” “be” or “due.”</p>
<p>In this example the length of the prefix is always two, but you can do Markov analysis with<br>
any prefix length. The length of the prefix is called the “order” of the analysis.<br>
<strong>Exercise 13.8.</strong> Markov analysis:</p>
<ol>
<li>Write a program to read a text from a file and perform Markov analysis. The result should be<br>
a dictionary that maps from prefixes to a collection of possible suffixes. The collection might<br>
be a list, tuple, or dictionary; it is up to you to make an appropriate choice. You can test your<br>
program with prefix length two, but you should write the program in a way that makes it easy<br>
to try other lengths.</li>
<li>Add a function to the previous program to generate random text based on the Markov analysis.<br>
Here is an example fromEmmawith prefix length 2:<br>
He was very clever, be it sweetness or be angry, ashamed or only amused, at such<br>
a stroke. She had never thought of Hannah till you were never meant for me?" “I<br>
cannot make speeches, Emma:” he soon cut it all himself.<br>
For this example, I left the punctuation attached to the words. The result is almost syntacti-<br>
cally correct, but not quite. Semantically, it almost makes sense, but not quite.<br>
What happens if you increase the prefix length? Does the random text make more sense?</li>
<li>Once your program is working, you might want to try a mash-up: if you analyze text from<br>
two or more books, the random text you generate will blend the vocabulary and phrases from<br>
the sources in interesting ways.</li>
</ol>
<p>Credit: This case study is based on an example from Kernighan and Pike,The Practice of Pro-<br>
gramming, Addison-Wesley, 1999.</p>
<p>You should attempt this exercise before you go on; then you can can download my<br>
solution fromhttp://thinkpython.com/code/markov.py. You will also needhttp://<br>
<a href="http://thinkpython.com/code/emma.txt">thinkpython.com/code/emma.txt</a>.</p>
<h3 id="data-structures">13.9 Data structures</h3>
<p>Using Markov analysis to generate random text is fun, but there is also a point to this<br>
exercise: data structure selection. In your solution to the previous exercises, you had to<br>
choose:</p>
<ul>
<li>How to represent the prefixes.</li>
</ul>
<p><strong>130 Chapter 13. Case study: data structure selection</strong></p>
<ul>
<li>How to represent the collection of possible suffixes.</li>
<li>How to represent the mapping from each prefix to the collection of possible suffixes.</li>
</ul>
<p>Ok, the last one is easy; the only mapping type we have seen is a dictionary, so it is the<br>
natural choice.</p>
<p>For the prefixes, the most obvious options are string, list of strings, or tuple of strings. For<br>
the suffixes, one option is a list; another is a histogram (dictionary).</p>
<p>How should you choose? The first step is to think about the operations you will need to<br>
implement for each data structure. For the prefixes, we need to be able to remove words<br>
from the beginning and add to the end. For example, if the current prefix is “Half a,” and<br>
the next word is “bee,” you need to be able to form the next prefix, “a bee.”</p>
<p>Your first choice might be a list, since it is easy to add and remove elements, but we also<br>
need to be able to use the prefixes as keys in a dictionary, so that rules out lists. With tuples,<br>
you can’t append or remove, but you can use the addition operator to form a new tuple:</p>
<p>def shift(prefix, word):<br>
return prefix[1:] + (word,)</p>
<p>shifttakes a tuple of words,prefix, and a string,word, and forms a new tuple that has<br>
all the words inprefixexcept the first, andwordadded to the end.</p>
<p>For the collection of suffixes, the operations we need to perform include adding a new<br>
suffix (or increasing the frequency of an existing one), and choosing a random suffix.</p>
<p>Adding a new suffix is equally easy for the list implementation or the histogram. Choosing<br>
a random element from a list is easy; choosing from a histogram is harder to do efficiently<br>
(see Exercise 13.7).</p>
<p>So far we have been talking mostly about ease of implementation, but there are other fac-<br>
tors to consider in choosing data structures. One is run time. Sometimes there is a theoreti-<br>
cal reason to expect one data structure to be faster than other; for example, I mentioned that<br>
theinoperator is faster for dictionaries than for lists, at least when the number of elements<br>
is large.</p>
<p>But often you don’t know ahead of time which implementation will be faster. One option is<br>
to implement both of them and see which is better. This approach is called <strong>benchmarking</strong>.<br>
A practical alternative is to choose the data structure that is easiest to implement, and then<br>
see if it is fast enough for the intended application. If so, there is no need to go on. If not,<br>
there are tools, like theprofilemodule, that can identify the places in a program that take<br>
the most time.</p>
<p>The other factor to consider is storage space. For example, using a histogram for the col-<br>
lection of suffixes might take less space because you only have to store each word once, no<br>
matter how many times it appears in the text. In some cases, saving space can also make<br>
your program run faster, and in the extreme, your program might not run at all if you run<br>
out of memory. But for many applications, space is a secondary consideration after run<br>
time.</p>
<p>One final thought: in this discussion, I have implied that we should use one data structure<br>
for both analysis and generation. But since these are separate phases, it would also be pos-<br>
sible to use one structure for analysis and then convert to another structure for generation.<br>
This would be a net win if the time saved during generation exceeded the time spent in<br>
conversion.</p>
<p><strong>13.10. Debugging 131</strong></p>
<h3 id="debugging">13.10 Debugging</h3>
<p>When you are debugging a program, and especially if you are working on a hard bug,<br>
there are four things to try:</p>
<p><strong>reading:</strong> Examine your code, read it back to yourself, and check that it says what you<br>
meant to say.</p>
<p><strong>running:</strong> Experiment by making changes and running different versions. Often if you dis-<br>
play the right thing at the right place in the program, the problem becomes obvious,<br>
but sometimes you have to spend some time to build scaffolding.</p>
<p><strong>ruminating:</strong> Take some time to think! What kind of error is it: syntax, runtime, semantic?<br>
What information can you get from the error messages, or from the output of the<br>
program? What kind of error could cause the problem you’re seeing? What did you<br>
change last, before the problem appeared?</p>
<p><strong>retreating:</strong> At some point, the best thing to do is back off, undoing recent changes, until<br>
you get back to a program that works and that you understand. Then you can start<br>
rebuilding.</p>
<p>Beginning programmers sometimes get stuck on one of these activities and forget the oth-<br>
ers. Each activity comes with its own failure mode.</p>
<p>For example, reading your code might help if the problem is a typographical error, but<br>
not if the problem is a conceptual misunderstanding. If you don’t understand what your<br>
program does, you can read it 100 times and never see the error, because the error is in<br>
your head.</p>
<p>Running experiments can help, especially if you run small, simple tests. But if you run<br>
experiments without thinking or reading your code, you might fall into a pattern I call<br>
“random walk programming,” which is the process of making random changes until the<br>
program does the right thing. Needless to say, random walk programming can take a long<br>
time.</p>
<p>You have to take time to think. Debugging is like an experimental science. You should have<br>
at least one hypothesis about what the problem is. If there are two or more possibilities, try<br>
to think of a test that would eliminate one of them.</p>
<p>Taking a break helps with the thinking. So does talking. If you explain the problem to<br>
someone else (or even yourself), you will sometimes find the answer before you finish<br>
asking the question.</p>
<p>But even the best debugging techniques will fail if there are too many errors, or if the code<br>
you are trying to fix is too big and complicated. Sometimes the best option is to retreat,<br>
simplifying the program until you get to something that works and that you understand.</p>
<p>Beginning programmers are often reluctant to retreat because they can’t stand to delete a<br>
line of code (even if it’s wrong). If it makes you feel better, copy your program into another<br>
file before you start stripping it down. Then you can paste the pieces back in a little bit at a<br>
time.</p>
<p>Finding a hard bug requires reading, running, ruminating, and sometimes retreating. If<br>
you get stuck on one of these activities, try the others.</p>
<p><strong>132 Chapter 13. Case study: data structure selection</strong></p>
<h3 id="glossary">13.11 Glossary</h3>
<p><strong>deterministic:</strong> Pertaining to a program that does the same thing each time it runs, given<br>
the same inputs.</p>
<p><strong>pseudorandom:</strong> Pertaining to a sequence of numbers that appear to be random, but are<br>
generated by a deterministic program.</p>
<p><strong>default value:</strong> The value given to an optional parameter if no argument is provided.</p>
<p><strong>override:</strong> To replace a default value with an argument.</p>
<p><strong>benchmarking:</strong> The process of choosing between data structures by implementing alter-<br>
natives and testing them on a sample of the possible inputs.</p>
<h3 id="exercises-1">13.12 Exercises</h3>
<p><strong>Exercise 13.9.</strong> The “rank” of a word is its position in a list of words sorted by frequency: the most<br>
common word has rank 1, the second most common has rank 2, etc.</p>
<p>Zipf’s law describes a relationship between the ranks and frequencies of words in natural languages<br>
(http: // en. wikipedia. org/ wiki/ Zipf’ s_ law). Specifically, it predicts that the frequency,<br>
f , of the word with rank r is:</p>
<pre><code>f=cr−s
</code></pre>
<p>where s and c are parameters that depend on the language and the text. If you take the logarithm of<br>
both sides of this equation, you get:</p>
<pre><code>logf=logc−slogr
</code></pre>
<p>So if you plot log f versus log r, you should get a straight line with slope−s and intercept log c.</p>
<p>Write a program that reads a text from a file, counts word frequencies, and prints one line for each<br>
word, in descending order of frequency, with log f and log r. Use the graphing program of your<br>
choice to plot the results and check whether they form a straight line. Can you estimate the value of<br>
s?</p>
<p>Solution:http: // thinkpython. com/ code/ zipf. py. To make the plots, you might have to<br>
install matplotlib (seehttp: // matplotlib. sourceforge. net/).</p>
<h2 id="chapter-14">Chapter 14</h2>
<h1 id="files">Files</h1>
<h3 id="persistence">14.1 Persistence</h3>
<p>Most of the programs we have seen so far are transient in the sense that they run for a short<br>
time and produce some output, but when they end, their data disappears. If you run the<br>
program again, it starts with a clean slate.</p>
<p>Other programs are <strong>persistent</strong> : they run for a long time (or all the time); they keep at least<br>
some of their data in permanent storage (a hard drive, for example); and if they shut down<br>
and restart, they pick up where they left off.</p>
<p>Examples of persistent programs are operating systems, which run pretty much whenever<br>
a computer is on, and web servers, which run all the time, waiting for requests to come in<br>
on the network.</p>
<p>One of the simplest ways for programs to maintain their data is by reading and writing<br>
text files. We have already seen programs that read text files; in this chapter we will see<br>
programs that write them.</p>
<p>An alternative is to store the state of the program in a database. In this chapter I will present<br>
a simple database and a module,pickle, that makes it easy to store program data.</p>
<h3 id="reading-and-writing">14.2 Reading and writing</h3>
<p>A text file is a sequence of characters stored on a permanent medium like a hard drive,<br>
flash memory, or CD-ROM. We saw how to open and read a file in Section 9.1.</p>
<p>To write a file, you have to open it with mode’w’as a second parameter:</p>
<blockquote>
<blockquote>
<blockquote>
<p>fout = open(‘output.txt’,‘w’)<br>
print fout<br>
&lt;open file’output.txt’, mode’w’at 0xb7eb2410&gt;</p>
</blockquote>
</blockquote>
</blockquote>
<p>If the file already exists, opening it in write mode clears out the old data and starts fresh,<br>
so be careful! If the file doesn’t exist, a new one is created.</p>
<p>Thewritemethod puts data into the file.</p>
<p><strong>134 Chapter 14. Files</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>line1 = “This here’s the wattle,\n”<br>
fout.write(line1)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Again, the file object keeps track of where it is, so if you callwriteagain, it adds the new<br>
data to the end.</p>
<blockquote>
<blockquote>
<blockquote>
<p>line2 = “the emblem of our land.\n”<br>
fout.write(line2)</p>
</blockquote>
</blockquote>
</blockquote>
<p>When you are done writing, you have to close the file.</p>
<blockquote>
<blockquote>
<blockquote>
<p>fout.close()</p>
</blockquote>
</blockquote>
</blockquote>
<h3 id="format-operator">14.3 Format operator</h3>
<p>The argument ofwritehas to be a string, so if we want to put other values in a file, we<br>
have to convert them to strings. The easiest way to do that is withstr:</p>
<blockquote>
<blockquote>
<blockquote>
<p>x = 52<br>
fout.write(str(x))</p>
</blockquote>
</blockquote>
</blockquote>
<p>An alternative is to use the <strong>format operator</strong> ,%. When applied to integers,%is the modulus<br>
operator. But when the first operand is a string,%is the format operator.</p>
<p>The first operand is the <strong>format string</strong> , which contains one or more <strong>format sequences</strong> ,<br>
which specify how the second operand is formatted. The result is a string.</p>
<p>For example, the format sequence’%d’means that the second operand should be format-<br>
ted as an integer (dstands for “decimal”):</p>
<blockquote>
<blockquote>
<blockquote>
<p>camels = 42<br>
‘%d’% camels<br>
’ 42 ’</p>
</blockquote>
</blockquote>
</blockquote>
<p>The result is the string’ 42 ', which is not to be confused with the integer value 42.</p>
<p>A format sequence can appear anywhere in the string, so you can embed a value in a<br>
sentence:</p>
<blockquote>
<blockquote>
<blockquote>
<p>camels = 42<br>
‘I have spotted %d camels.’ % camels<br>
‘I have spotted 42 camels.’</p>
</blockquote>
</blockquote>
</blockquote>
<p>If there is more than one format sequence in the string, the second argument has to be a<br>
tuple. Each format sequence is matched with an element of the tuple, in order.</p>
<p>The following example uses’%d’to format an integer,’%g’to format a floating-point num-<br>
ber (don’t ask why), and’%s’to format a string:</p>
<blockquote>
<blockquote>
<blockquote>
<p>‘In %d years I have spotted %g %s.’ % (3, 0.1,‘camels’)<br>
‘In 3 years I have spotted 0.1 camels.’</p>
</blockquote>
</blockquote>
</blockquote>
<p>The number of elements in the tuple has to match the number of format sequences in the<br>
string. Also, the types of the elements have to match the format sequences:</p>
<blockquote>
<blockquote>
<blockquote>
<p>‘%d %d %d’ % (1, 2)<br>
TypeError: not enough arguments for format string</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>‘%d’% ‘dollars’<br>
TypeError: illegal argument type for built-in operation</p>
</blockquote>
</blockquote>
</blockquote>
<p><strong>14.4. Filenames and paths 135</strong></p>
<p>In the first example, there aren’t enough elements; in the second, the element is the wrong<br>
type.</p>
<p>The format operator is powerful, but it can be difficult to use. You can read more about it<br>
athttp://docs.python.org/2/library/stdtypes.html#string- formatting.</p>
<h3 id="filenames-and-paths">14.4 Filenames and paths</h3>
<p>Files are organized into <strong>directories</strong> (also called “folders”). Every running program has a<br>
“current directory,” which is the default directory for most operations. For example, when<br>
you open a file for reading, Python looks for it in the current directory.</p>
<p>Theosmodule provides functions for working with files and directories (“os” stands for<br>
“operating system”).os.getcwdreturns the name of the current directory:</p>
<blockquote>
<blockquote>
<blockquote>
<p>import os<br>
cwd = os.getcwd()<br>
print cwd<br>
/home/dinsdale</p>
</blockquote>
</blockquote>
</blockquote>
<p>cwdstands for “current working directory.” The result in this example is/home/dinsdale,<br>
which is the home directory of a user nameddinsdale.</p>
<p>A string likecwdthat identifies a file is called a <strong>path</strong>. A <strong>relative path</strong> starts from the current<br>
directory; an <strong>absolute path</strong> starts from the topmost directory in the file system.</p>
<p>The paths we have seen so far are simple filenames, so they are relative to the current<br>
directory. To find the absolute path to a file, you can useos.path.abspath:</p>
<blockquote>
<blockquote>
<blockquote>
<p>os.path.abspath(‘memo.txt’)<br>
‘/home/dinsdale/memo.txt’</p>
</blockquote>
</blockquote>
</blockquote>
<p>os.path.existschecks whether a file or directory exists:</p>
<blockquote>
<blockquote>
<blockquote>
<p>os.path.exists(‘memo.txt’)<br>
True</p>
</blockquote>
</blockquote>
</blockquote>
<p>If it exists,os.path.isdirchecks whether it’s a directory:</p>
<blockquote>
<blockquote>
<blockquote>
<p>os.path.isdir(‘memo.txt’)<br>
False</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>os.path.isdir(‘music’)<br>
True</p>
</blockquote>
</blockquote>
</blockquote>
<p>Similarly,os.path.isfilechecks whether it’s a file.</p>
<p>os.listdirreturns a list of the files (and other directories) in the given directory:</p>
<blockquote>
<blockquote>
<blockquote>
<p>os.listdir(cwd)<br>
[‘music’, ‘photos’,‘memo.txt’]</p>
</blockquote>
</blockquote>
</blockquote>
<p>To demonstrate these functions, the following example “walks” through a directory, prints<br>
the names of all the files, and calls itself recursively on all the directories.</p>
<p>def walk(dirname):<br>
for name in os.listdir(dirname):<br>
path = os.path.join(dirname, name)</p>
<p><strong>136 Chapter 14. Files</strong></p>
<pre><code>if os.path.isfile(path):
print path
else:
walk(path)
</code></pre>
<p>os.path.jointakes a directory and a file name and joins them into a complete path.<br>
<strong>Exercise 14.1.</strong> Theosmodule provides a function calledwalkthat is similar to this one but more<br>
versatile. Read the documentation and use it to print the names of the files in a given directory and<br>
its subdirectories.</p>
<p>Solution:http: // thinkpython. com/ code/ walk. py.</p>
<h3 id="catching-exceptions">14.5 Catching exceptions</h3>
<p>A lot of things can go wrong when you try to read and write files. If you try to open a file<br>
that doesn’t exist, you get anIOError:</p>
<blockquote>
<blockquote>
<blockquote>
<p>fin = open(‘bad_file’)<br>
IOError: [Errno 2] No such file or directory: ‘bad_file’</p>
</blockquote>
</blockquote>
</blockquote>
<p>If you don’t have permission to access a file:</p>
<blockquote>
<blockquote>
<blockquote>
<p>fout = open(’/etc/passwd’, ‘w’)<br>
IOError: [Errno 13] Permission denied:’/etc/passwd’</p>
</blockquote>
</blockquote>
</blockquote>
<p>And if you try to open a directory for reading, you get</p>
<blockquote>
<blockquote>
<blockquote>
<p>fin = open(’/home’)<br>
IOError: [Errno 21] Is a directory</p>
</blockquote>
</blockquote>
</blockquote>
<p>To avoid these errors, you could use functions likeos.path.existsandos.path.isfile,<br>
but it would take a lot of time and code to check all the possibilities (if “Errno 21” is any<br>
indication, there are at least 21 things that can go wrong).</p>
<p>It is better to go ahead and try—and deal with problems if they happen—which is exactly<br>
what thetrystatement does. The syntax is similar to anifstatement:</p>
<p>try:<br>
fin = open(‘bad_file’)<br>
for line in fin:<br>
print line<br>
fin.close()<br>
except:<br>
print ‘Something went wrong.’</p>
<p>Python starts by executing thetryclause. If all goes well, it skips theexceptclause and<br>
proceeds. If an exception occurs, it jumps out of thetryclause and executes theexcept<br>
clause.</p>
<p>Handling an exception with atrystatement is called <strong>catching</strong> an exception. In this exam-<br>
ple, theexceptclause prints an error message that is not very helpful. In general, catching<br>
an exception gives you a chance to fix the problem, or try again, or at least end the program<br>
gracefully.<br>
<strong>Exercise 14.2.</strong> Write a function calledsedthat takes as arguments a pattern string, a replacement<br>
string, and two filenames; it should read the first file and write the contents into the second file<br>
(creating it if necessary). If the pattern string appears anywhere in the file, it should be replaced<br>
with the replacement string.</p>
<p><strong>14.6. Databases 137</strong></p>
<p>If an error occurs while opening, reading, writing or closing files, your program should catch the<br>
exception, print an error message, and exit. Solution:http: // thinkpython. com/ code/ sed.<br>
py.</p>
<h3 id="databases">14.6 Databases</h3>
<p>A <strong>database</strong> is a file that is organized for storing data. Most databases are organized like a<br>
dictionary in the sense that they map from keys to values. The biggest difference is that the<br>
database is on disk (or other permanent storage), so it persists after the program ends.</p>
<p>The moduleanydbmprovides an interface for creating and updating database files. As an<br>
example, I’ll create a database that contains captions for image files.</p>
<p>Opening a database is similar to opening other files:</p>
<blockquote>
<blockquote>
<blockquote>
<p>import anydbm<br>
db = anydbm.open(‘captions.db’, ‘c’)</p>
</blockquote>
</blockquote>
</blockquote>
<p>The mode’c’means that the database should be created if it doesn’t already exist. The<br>
result is a database object that can be used (for most operations) like a dictionary. If you<br>
create a new item,anydbmupdates the database file.</p>
<blockquote>
<blockquote>
<blockquote>
<p>db[‘cleese.png’] =‘Photo of John Cleese.’</p>
</blockquote>
</blockquote>
</blockquote>
<p>When you access one of the items,anydbmreads the file:</p>
<blockquote>
<blockquote>
<blockquote>
<p>print db[‘cleese.png’]<br>
Photo of John Cleese.</p>
</blockquote>
</blockquote>
</blockquote>
<p>If you make another assignment to an existing key,anydbmreplaces the old value:</p>
<blockquote>
<blockquote>
<blockquote>
<p>db[‘cleese.png’] =‘Photo of John Cleese doing a silly walk.’<br>
print db[‘cleese.png’]<br>
Photo of John Cleese doing a silly walk.</p>
</blockquote>
</blockquote>
</blockquote>
<p>Many dictionary methods, likekeysanditems, also work with database objects. So does<br>
iteration with aforstatement.</p>
<p>for key in db:<br>
print key</p>
<p>As with other files, you should close the database when you are done:</p>
<blockquote>
<blockquote>
<blockquote>
<p>db.close()</p>
</blockquote>
</blockquote>
</blockquote>
<h3 id="pickling">14.7 Pickling</h3>
<p>A limitation ofanydbmis that the keys and values have to be strings. If you try to use any<br>
other type, you get an error.</p>
<p>Thepicklemodule can help. It translates almost any type of object into a string suitable<br>
for storage in a database, and then translates strings back into objects.</p>
<p>pickle.dumpstakes an object as a parameter and returns a string representation (dumpsis<br>
short for “dump string”):</p>
<p><strong>138 Chapter 14. Files</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>import pickle<br>
t = [1, 2, 3]<br>
pickle.dumps(t)<br>
‘(lp0\nI1\naI2\naI3\na.’</p>
</blockquote>
</blockquote>
</blockquote>
<p>The format isn’t obvious to human readers; it is meant to be easy forpickleto interpret.<br>
pickle.loads(“load string”) reconstitutes the object:</p>
<blockquote>
<blockquote>
<blockquote>
<p>t1 = [1, 2, 3]<br>
s = pickle.dumps(t1)<br>
t2 = pickle.loads(s)<br>
print t2<br>
[1, 2, 3]</p>
</blockquote>
</blockquote>
</blockquote>
<p>Although the new object has the same value as the old, it is not (in general) the same object:</p>
<blockquote>
<blockquote>
<blockquote>
<p>t1 == t2<br>
True</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>t1 is t2<br>
False</p>
</blockquote>
</blockquote>
</blockquote>
<p>In other words, pickling and then unpickling has the same effect as copying the object.</p>
<p>You can usepickleto store non-strings in a database. In fact, this combination is so com-<br>
mon that it has been encapsulated in a module calledshelve.<br>
<strong>Exercise 14.3.</strong> If you download my solution to Exercise 12.4 fromhttp: // thinkpython. com/<br>
code/ anagram_ sets. py, you’ll see that it creates a dictionary that maps from a sorted string of<br>
letters to the list of words that can be spelled with those letters. For example,'opst’maps to the<br>
list[‘opts’, ‘post’, ‘pots’, ‘spot’, ‘stop’, ‘tops’].</p>
<p>Write a module that importsanagram_setsand provides two new functions:store_anagrams<br>
should store the anagram dictionary in a “shelf;”read_anagramsshould look up a word and return<br>
a list of its anagrams. Solution:http: // thinkpython. com/ code/ anagram_ db. py</p>
<h3 id="pipes">14.8 Pipes</h3>
<p>Most operating systems provide a command-line interface, also known as a <strong>shell</strong>. Shells<br>
usually provide commands to navigate the file system and launch applications. For exam-<br>
ple, in Unix you can change directories withcd, display the contents of a directory withls,<br>
and launch a web browser by typing (for example)firefox.</p>
<p>Any program that you can launch from the shell can also be launched from Python using<br>
a <strong>pipe</strong>. A pipe is an object that represents a running program.</p>
<p>For example, the Unix commandls -lnormally displays the contents of the current di-<br>
rectory (in long format). You can launchlswithos.popen^1 :</p>
<blockquote>
<blockquote>
<blockquote>
<p>cmd = ‘ls -l’<br>
fp = os.popen(cmd)</p>
</blockquote>
</blockquote>
</blockquote>
<p>The argument is a string that contains a shell command. The return value is an object that<br>
behaves just like an open file. You can read the output from thelsprocess one line at a<br>
time withreadlineor get the whole thing at once withread:</p>
<p>(^1) popenis deprecated now, which means we are supposed to stop using it and start using thesubprocess<br>
module. But for simple cases, I findsubprocessmore complicated than necessary. So I am going to keep using<br>
popenuntil they take it away.</p>
<p><strong>14.9. Writing modules 139</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>res = fp.read()</p>
</blockquote>
</blockquote>
</blockquote>
<p>When you are done, you close the pipe like a file:</p>
<blockquote>
<blockquote>
<blockquote>
<p>stat = fp.close()<br>
print stat<br>
None</p>
</blockquote>
</blockquote>
</blockquote>
<p>The return value is the final status of thelsprocess;Nonemeans that it ended normally<br>
(with no errors).</p>
<p>For example, most Unix systems provide a command calledmd5sumthat reads the contents<br>
of a file and computes a “checksum.” You can read about MD5 at <a href="http://en.wikipedia.org/wiki/Md5">http://en.wikipedia.org/wiki/Md5</a> . This command provides an efficient way to check whether two files have<br>
the same contents. The probability that different contents yield the same checksum is very<br>
small (that is, unlikely to happen before the universe collapses).</p>
<p>You can use a pipe to runmd5sumfrom Python and get the result:</p>
<blockquote>
<blockquote>
<blockquote>
<p>filename =‘book.tex’<br>
cmd ='md5sum '+ filename<br>
fp = os.popen(cmd)<br>
res = fp.read()<br>
stat = fp.close()<br>
print res<br>
1e0033f0ed0656636de0d75144ba32e0 book.tex</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>print stat<br>
None<br>
<strong>Exercise 14.4.</strong> In a large collection of MP3 files, there may be more than one copy of the same song,<br>
stored in different directories or with different file names. The goal of this exercise is to search for<br>
duplicates.</p>
</blockquote>
</blockquote>
</blockquote>
<ol>
<li>Write a program that searches a directory and all of its subdirectories, recursively, and returns<br>
a list of complete paths for all files with a given suffix (like.mp3). Hint:os.pathprovides<br>
several useful functions for manipulating file and path names.</li>
<li>To recognize duplicates, you can usemd5sumto compute a “checksum” for each files. If two<br>
files have the same checksum, they probably have the same contents.</li>
<li>To double-check, you can use the Unix commanddiff.</li>
</ol>
<p>Solution:http: // thinkpython. com/ code/ find_ duplicates. py.</p>
<h3 id="writing-modules">14.9 Writing modules</h3>
<p>Any file that contains Python code can be imported as a module. For example, suppose<br>
you have a file namedwc.pywith the following code:</p>
<p>def linecount(filename):<br>
count = 0<br>
for line in open(filename):<br>
count += 1<br>
return count</p>
<p>print linecount(‘<a href="http://wc.py">wc.py</a>’)</p>
<p><strong>140 Chapter 14. Files</strong></p>
<p>If you run this program, it reads itself and prints the number of lines in the file, which is 7.<br>
You can also import it like this:</p>
<blockquote>
<blockquote>
<blockquote>
<p>import wc<br>
7</p>
</blockquote>
</blockquote>
</blockquote>
<p>Now you have a module objectwc:</p>
<blockquote>
<blockquote>
<blockquote>
<p>print wc<br>
&lt;module’wc’from ‘<a href="http://wc.py">wc.py</a>’&gt;</p>
</blockquote>
</blockquote>
</blockquote>
<p>That provides a function calledlinecount:</p>
<blockquote>
<blockquote>
<blockquote>
<p>wc.linecount(‘<a href="http://wc.py">wc.py</a>’)<br>
7</p>
</blockquote>
</blockquote>
</blockquote>
<p>So that’s how you write modules in Python.</p>
<p>The only problem with this example is that when you import the module it executes the<br>
test code at the bottom. Normally when you import a module, it defines new functions but<br>
it doesn’t execute them.</p>
<p>Programs that will be imported as modules often use the following idiom:</p>
<p>if <strong>name</strong> == ‘<strong>main</strong>’:<br>
print linecount(‘<a href="http://wc.py">wc.py</a>’)</p>
<p>__name__is a built-in variable that is set when the program starts. If the program is run-<br>
ning as a script,<strong>name__has the value__main</strong>; in that case, the test code is executed.<br>
Otherwise, if the module is being imported, the test code is skipped.<br>
<strong>Exercise 14.5.</strong> Type this example into a file namedwc.pyand run it as a script. Then run the<br>
Python interpreter andimport wc. What is the value of__name__when the module is being<br>
imported?</p>
<p>Warning: If you import a module that has already been imported, Python does nothing. It does not<br>
re-read the file, even if it has changed.</p>
<p>If you want to reload a module, you can use the built-in functionreload, but it can be tricky, so<br>
the safest thing to do is restart the interpreter and then import the module again.</p>
<h3 id="debugging-1">14.10 Debugging</h3>
<p>When you are reading and writing files, you might run into problems with whitespace.<br>
These errors can be hard to debug because spaces, tabs and newlines are normally invisible:</p>
<blockquote>
<blockquote>
<blockquote>
<p>s =‘1 2\t 3\n 4’<br>
print s<br>
1 2 3<br>
4</p>
</blockquote>
</blockquote>
</blockquote>
<p>The built-in functionreprcan help. It takes any object as an argument and returns a string<br>
representation of the object. For strings, it represents whitespace characters with backslash<br>
sequences:</p>
<blockquote>
<blockquote>
<blockquote>
<p>print repr(s)<br>
‘1 2\t 3\n 4’</p>
</blockquote>
</blockquote>
</blockquote>
<p><strong>14.11. Glossary 141</strong></p>
<p>This can be helpful for debugging.</p>
<p>One other problem you might run into is that different systems use different characters to<br>
indicate the end of a line. Some systems use a newline, represented\n. Others use a return<br>
character, represented\r. Some use both. If you move files between different systems,<br>
these inconsistencies might cause problems.</p>
<p>For most systems, there are applications to convert from one format to another. You can<br>
find them (and read more about this issue) at <a href="http://en.wikipedia.org/wiki/Newline">http://en.wikipedia.org/wiki/Newline</a> . Or, of course, you could write one yourself.</p>
<h3 id="glossary-1">14.11 Glossary</h3>
<p><strong>persistent:</strong> Pertaining to a program that runs indefinitely and keeps at least some of its<br>
data in permanent storage.</p>
<p><strong>format operator:</strong> An operator,%, that takes a format string and a tuple and generates a<br>
string that includes the elements of the tuple formatted as specified by the format<br>
string.</p>
<p><strong>format string:</strong> A string, used with the format operator, that contains format sequences.</p>
<p><strong>format sequence:</strong> A sequence of characters in a format string, like%d, that specifies how a<br>
value should be formatted.</p>
<p><strong>text file:</strong> A sequence of characters stored in permanent storage like a hard drive.</p>
<p><strong>directory:</strong> A named collection of files, also called a folder.</p>
<p><strong>path:</strong> A string that identifies a file.</p>
<p><strong>relative path:</strong> A path that starts from the current directory.</p>
<p><strong>absolute path:</strong> A path that starts from the topmost directory in the file system.</p>
<p><strong>catch:</strong> To prevent an exception from terminating a program using thetryandexceptstate-<br>
ments.</p>
<p><strong>database:</strong> A file whose contents are organized like a dictionary with keys that correspond<br>
to values.</p>
<h3 id="exercises-2">14.12 Exercises</h3>
<p><strong>Exercise 14.6.</strong> Theurllibmodule provides methods for manipulating URLs and downloading<br>
information from the web. The following example downloads and prints a secret message from <a href="http://thinkpython.com">http://thinkpython.com</a> :</p>
<pre><code>import urllib
conn = urllib.urlopen('http://thinkpython.com/secret.html')
for line in conn:
	print line.strip()
</code></pre>
<p>Run this code and follow the instructions you see there.<br>
Solution: <a href="http://thinkpython.com/code/zip_code.py">http://thinkpython.com/code/zip_code.py</a></p>
<p><strong>142 Chapter 14. Files</strong></p>
<h2 id="chapter-15">Chapter 15</h2>
<h1 id="classes-and-objects">Classes and objects</h1>
<p>Code examples from this chapter are available fromhttp://thinkpython.com/code/<br>
<a href="http://Point1.py">Point1.py</a>; solutions to the exercises are available fromhttp://thinkpython.com/code/<br>
Point1_soln.py.</p>
<h3 id="user-defined-types">15.1 User-defined types</h3>
<p>We have used many of Python’s built-in types; now we are going to define a new type. As<br>
an example, we will create a type calledPointthat represents a point in two-dimensional<br>
space.</p>
<p>In mathematical notation, points are often written in parentheses with a comma separating<br>
the coordinates. For example,(0, 0)represents the origin, and(x,y)represents the pointx<br>
units to the right andyunits up from the origin.</p>
<p>There are several ways we might represent points in Python:</p>
<ul>
<li>We could store the coordinates separately in two variables,xandy.</li>
<li>We could store the coordinates as elements in a list or tuple.</li>
<li>We could create a new type to represent points as objects.</li>
</ul>
<p>Creating a new type is (a little) more complicated than the other options, but it has advan-<br>
tages that will be apparent soon.</p>
<p>A user-defined type is also called a <strong>class</strong>. A class definition looks like this:</p>
<p>class Point(object):<br>
“”“Represents a point in 2-D space.”""</p>
<p>This header indicates that the new class is aPoint, which is a kind ofobject, which is a<br>
built-in type.</p>
<p>The body is a docstring that explains what the class is for. You can define variables and<br>
functions inside a class definition, but we will get back to that later.</p>
<p>Defining a class namedPointcreates a class object.</p>
<p><strong>144 Chapter 15. Classes and objects</strong></p>
<pre><code>x
y
</code></pre>
<pre><code>3.0
4.0
</code></pre>
<pre><code>blank
</code></pre>
<pre><code>Point
</code></pre>
<pre><code>Figure 15.1: Object diagram.
</code></pre>
<blockquote>
<blockquote>
<blockquote>
<p>print Point<br>
&lt;class ‘<strong>main</strong>.Point’&gt;</p>
</blockquote>
</blockquote>
</blockquote>
<p>BecausePointis defined at the top level, its “full name” is__main__.Point.</p>
<p>The class object is like a factory for creating objects. To create a Point, you callPointas if it<br>
were a function.</p>
<blockquote>
<blockquote>
<blockquote>
<p>blank = Point()<br>
print blank<br>
&lt;<strong>main</strong>.Point instance at 0xb7e9d3ac&gt;</p>
</blockquote>
</blockquote>
</blockquote>
<p>The return value is a reference to a Point object, which we assign toblank. Creating a new<br>
object is called <strong>instantiation</strong> , and the object is an <strong>instance</strong> of the class.</p>
<p>When you print an instance, Python tells you what class it belongs to and where it is stored<br>
in memory (the prefix0xmeans that the following number is in hexadecimal).</p>
<h3 id="attributes">15.2 Attributes</h3>
<p>You can assign values to an instance using dot notation:</p>
<blockquote>
<blockquote>
<blockquote>
<p>blank.x = 3.0<br>
blank.y = 4.0</p>
</blockquote>
</blockquote>
</blockquote>
<p>This syntax is similar to the syntax for selecting a variable from a module, such asmath.pi<br>
orstring.whitespace. In this case, though, we are assigning values to named elements of<br>
an object. These elements are called <strong>attributes</strong>.</p>
<p>As a noun, “AT-trib-ute” is pronounced with emphasis on the first syllable, as opposed to<br>
“a-TRIB-ute,” which is a verb.</p>
<p>The following diagram shows the result of these assignments. A state diagram that shows<br>
an object and its attributes is called an <strong>object diagram</strong> ; see Figure 15.1.</p>
<p>The variableblankrefers to a Point object, which contains two attributes. Each attribute<br>
refers to a floating-point number.</p>
<p>You can read the value of an attribute using the same syntax:</p>
<blockquote>
<blockquote>
<blockquote>
<p>print blank.y<br>
4.0</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>x = blank.x<br>
print x<br>
3.0</p>
</blockquote>
</blockquote>
</blockquote>
<p>The expressionblank.xmeans, “Go to the objectblankrefers to and get the value ofx.”<br>
In this case, we assign that value to a variable namedx. There is no conflict between the<br>
variablexand the attributex.</p>
<p>You can use dot notation as part of any expression. For example:</p>
<p><strong>15.3. Rectangles 145</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>print’(%g, %g)’% (blank.x, blank.y)<br>
(3.0, 4.0)</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>distance = math.sqrt(blank.x<strong>2 + blank.y</strong>2)<br>
print distance<br>
5.0</p>
</blockquote>
</blockquote>
</blockquote>
<p>You can pass an instance as an argument in the usual way. For example:</p>
<p>def print_point§:<br>
print’(%g, %g)’% (p.x, p.y)</p>
<p>print_pointtakes a point as an argument and displays it in mathematical notation. To<br>
invoke it, you can passblankas an argument:</p>
<blockquote>
<blockquote>
<blockquote>
<p>print_point(blank)<br>
(3.0, 4.0)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Inside the function,pis an alias forblank, so if the function modifiesp,blankchanges.<br>
<strong>Exercise 15.1.</strong> Write a function calleddistance_between_pointsthat takes two Points as ar-<br>
guments and returns the distance between them.</p>
<h3 id="rectangles">15.3 Rectangles</h3>
<p>Sometimes it is obvious what the attributes of an object should be, but other times you have<br>
to make decisions. For example, imagine you are designing a class to represent rectangles.<br>
What attributes would you use to specify the location and size of a rectangle? You can ig-<br>
nore angle; to keep things simple, assume that the rectangle is either vertical or horizontal.</p>
<p>There are at least two possibilities:</p>
<ul>
<li>You could specify one corner of the rectangle (or the center), the width, and the<br>
height.</li>
<li>You could specify two opposing corners.</li>
</ul>
<p>At this point it is hard to say whether either is better than the other, so we’ll implement the<br>
first one, just as an example.</p>
<p>Here is the class definition:</p>
<p>class Rectangle(object):<br>
“”"Represents a rectangle.</p>
<pre><code>attributes: width, height, corner.
"""
</code></pre>
<p>The docstring lists the attributes:widthandheightare numbers;corneris a Point object<br>
that specifies the lower-left corner.</p>
<p>To represent a rectangle, you have to instantiate a Rectangle object and assign values to the<br>
attributes:</p>
<p>box = Rectangle()<br>
box.width = 100.0<br>
box.height = 200.0</p>
<p><strong>146 Chapter 15. Classes and objects</strong></p>
<pre><code>y
</code></pre>
<pre><code>x 0.0
0.0
</code></pre>
<pre><code>width 100.0
</code></pre>
<pre><code>corner
</code></pre>
<pre><code>200.0
</code></pre>
<pre><code>Point
</code></pre>
<pre><code>Rectangle
box
height
</code></pre>
<pre><code>Figure 15.2: Object diagram.
</code></pre>
<p>box.corner = Point()<br>
box.corner.x = 0.0<br>
box.corner.y = 0.0</p>
<p>The expressionbox.corner.xmeans, “Go to the objectboxrefers to and select the attribute<br>
namedcorner; then go to that object and select the attribute namedx.”</p>
<p>Figure 15.2 shows the state of this object. An object that is an attribute of another object is<br>
<strong>embedded</strong>.</p>
<h3 id="instances-as-return-values">15.4 Instances as return values</h3>
<p>Functions can return instances. For example,find_centertakes aRectangleas an argu-<br>
ment and returns aPointthat contains the coordinates of the center of theRectangle:</p>
<p>def find_center(rect):<br>
p = Point()<br>
p.x = rect.corner.x + rect.width/2.0<br>
p.y = rect.corner.y + rect.height/2.0<br>
return p</p>
<p>Here is an example that passesboxas an argument and assigns the resulting Point to<br>
center:</p>
<blockquote>
<blockquote>
<blockquote>
<p>center = find_center(box)<br>
print_point(center)<br>
(50.0, 100.0)</p>
</blockquote>
</blockquote>
</blockquote>
<h3 id="objects-are-mutable">15.5 Objects are mutable</h3>
<p>You can change the state of an object by making an assignment to one of its attributes. For<br>
example, to change the size of a rectangle without changing its position, you can modify<br>
the values ofwidthandheight:</p>
<p>box.width = box.width + 50<br>
box.height = box.width + 100</p>
<p>You can also write functions that modify objects. For example,grow_rectangletakes a<br>
Rectangle object and two numbers,dwidthanddheight, and adds the numbers to the<br>
width and height of the rectangle:</p>
<p>def grow_rectangle(rect, dwidth, dheight):<br>
rect.width += dwidth<br>
rect.height += dheight</p>
<p><strong>15.6. Copying 147</strong></p>
<p>Here is an example that demonstrates the effect:</p>
<blockquote>
<blockquote>
<blockquote>
<p>print box.width<br>
100.0</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>print box.height<br>
200.0</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>grow_rectangle(box, 50, 100)<br>
print box.width<br>
150.0</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>print box.height<br>
300.0</p>
</blockquote>
</blockquote>
</blockquote>
<p>Inside the function,rectis an alias forbox, so if the function modifiesrect,boxchanges.<br>
<strong>Exercise 15.2.</strong> Write a function namedmove_rectanglethat takes a Rectangle and two numbers<br>
nameddxanddy. It should change the location of the rectangle by addingdxto thexcoordinate of<br>
cornerand addingdyto theycoordinate ofcorner.</p>
<h3 id="copying">15.6 Copying</h3>
<p>Aliasing can make a program difficult to read because changes in one place might have<br>
unexpected effects in another place. It is hard to keep track of all the variables that might<br>
refer to a given object.</p>
<p>Copying an object is often an alternative to aliasing. Thecopymodule contains a function<br>
calledcopythat can duplicate any object:</p>
<blockquote>
<blockquote>
<blockquote>
<p>p1 = Point()<br>
p1.x = 3.0<br>
p1.y = 4.0</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>import copy<br>
p2 = copy.copy(p1)</p>
</blockquote>
</blockquote>
</blockquote>
<p>p1andp2contain the same data, but they are not the same Point.</p>
<blockquote>
<blockquote>
<blockquote>
<p>print_point(p1)<br>
(3.0, 4.0)</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>print_point(p2)<br>
(3.0, 4.0)</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>p1 is p2<br>
False</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>p1 == p2<br>
False</p>
</blockquote>
</blockquote>
</blockquote>
<p>Theisoperator indicates thatp1andp2are not the same object, which is what we expected.<br>
But you might have expected==to yieldTruebecause these points contain the same data.<br>
In that case, you will be disappointed to learn that for instances, the default behavior of the<br>
==operator is the same as theisoperator; it checks object identity, not object equivalence.<br>
This behavior can be changed—we’ll see how later.</p>
<p>If you usecopy.copyto duplicate a Rectangle, you will find that it copies the Rectangle<br>
object but not the embedded Point.</p>
<p><strong>148 Chapter 15. Classes and objects</strong></p>
<pre><code>y
</code></pre>
<pre><code>x 0.0
0.0
</code></pre>
<pre><code>width
height
</code></pre>
<pre><code>100.0
</code></pre>
<pre><code>corner
</code></pre>
<pre><code>200.0
</code></pre>
<pre><code>box 100.0
200.0
</code></pre>
<pre><code>width
height
corner
</code></pre>
<pre><code>box2
</code></pre>
<pre><code>Figure 15.3: Object diagram.
</code></pre>
<blockquote>
<blockquote>
<blockquote>
<p>box2 = copy.copy(box)<br>
box2 is box<br>
False</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>box2.corner is box.corner<br>
True</p>
</blockquote>
</blockquote>
</blockquote>
<p>Figure 15.3 shows what the object diagram looks like. This operation is called a <strong>shallow<br>
copy</strong> because it copies the object and any references it contains, but not the embedded<br>
objects.</p>
<p>For most applications, this is not what you want. In this example, invoking<br>
grow_rectangle on one of the Rectangles would not affect the other, but invoking<br>
move_rectangleon either would affect both! This behavior is confusing and error-prone.</p>
<p>Fortunately, thecopymodule contains a method nameddeepcopythat copies not only the<br>
object but also the objects it refers to, and the objectstheyrefer to, and so on. You will not<br>
be surprised to learn that this operation is called a <strong>deep copy</strong>.</p>
<blockquote>
<blockquote>
<blockquote>
<p>box3 = copy.deepcopy(box)<br>
box3 is box<br>
False</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>box3.corner is box.corner<br>
False</p>
</blockquote>
</blockquote>
</blockquote>
<p>box3andboxare completely separate objects.<br>
<strong>Exercise 15.3.</strong> Write a version ofmove_rectanglethat creates and returns a new Rectangle<br>
instead of modifying the old one.</p>
<h3 id="debugging-2">15.7 Debugging</h3>
<p>When you start working with objects, you are likely to encounter some new exceptions. If<br>
you try to access an attribute that doesn’t exist, you get anAttributeError:</p>
<blockquote>
<blockquote>
<blockquote>
<p>p = Point()<br>
print p.z<br>
AttributeError: Point instance has no attribute’z’</p>
</blockquote>
</blockquote>
</blockquote>
<p>If you are not sure what type an object is, you can ask:</p>
<blockquote>
<blockquote>
<blockquote>
<p>type§<br>
&lt;type ‘<strong>main</strong>.Point’&gt;</p>
</blockquote>
</blockquote>
</blockquote>
<p>If you are not sure whether an object has a particular attribute, you can use the built-in<br>
functionhasattr:</p>
<blockquote>
<blockquote>
<blockquote>
<p>hasattr(p, ‘x’)<br>
True</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>hasattr(p, ‘z’)<br>
False</p>
</blockquote>
</blockquote>
</blockquote>
<p><strong>15.8. Glossary 149</strong></p>
<p>The first argument can be any object; the second argument is astringthat contains the name<br>
of the attribute.</p>
<h3 id="glossary-2">15.8 Glossary</h3>
<p><strong>class:</strong> A user-defined type. A class definition creates a new class object.</p>
<p><strong>class object:</strong> An object that contains information about a user-defined type. The class ob-<br>
ject can be used to create instances of the type.</p>
<p><strong>instance:</strong> An object that belongs to a class.</p>
<p><strong>attribute:</strong> One of the named values associated with an object.</p>
<p><strong>embedded (object):</strong> An object that is stored as an attribute of another object.</p>
<p><strong>shallow copy:</strong> To copy the contents of an object, including any references to embedded<br>
objects; implemented by thecopyfunction in thecopymodule.</p>
<p><strong>deep copy:</strong> To copy the contents of an object as well as any embedded objects, and any<br>
objects embedded in them, and so on; implemented by thedeepcopyfunction in the<br>
copymodule.</p>
<p><strong>object diagram:</strong> A diagram that shows objects, their attributes, and the values of the at-<br>
tributes.</p>
<h3 id="exercises-3">15.9 Exercises</h3>
<p><strong>Exercise 15.4.</strong> Swampy (see Chapter 4) provides a module namedWorld, which defines a user-<br>
defined type also calledWorld. You can import it like this:</p>
<p>from swampy.World import World</p>
<p>Or, depending on how you installed Swampy, like this:</p>
<p>from World import World</p>
<p>The following code creates a World object and calls themainloopmethod, which waits for the user.</p>
<p>world = World()<br>
world.mainloop()</p>
<p>A window should appear with a title bar and an empty square. We will use this window to draw<br>
Points, Rectangles and other shapes. Add the following lines before callingmainloopand run the<br>
program again.</p>
<p>canvas = <a href="http://world.ca">world.ca</a>(width=500, height=500, background=‘white’)<br>
bbox = [[-150,-100], [150, 100]]<br>
canvas.rectangle(bbox, outline=‘black’, width=2, fill=‘green4’)</p>
<p>You should see a green rectangle with a black outline. The first line creates a Canvas, which appears<br>
in the window as a white square. The Canvas object provides methods likerectanglefor drawing<br>
various shapes.</p>
<p>bboxis a list of lists that represents the “bounding box” of the rectangle. The first pair of coordinates<br>
is the lower-left corner of the rectangle; the second pair is the upper-right corner.</p>
<p>You can draw a circle like this:</p>
<p><strong>150 Chapter 15. Classes and objects</strong></p>
<p>canvas.circle([-25,0], 70, outline=None, fill=‘red’)</p>
<p>The first parameter is the coordinate pair for the center of the circle; the second parameter is the<br>
radius.</p>
<p>If you add this line to the program, the result should resemble the national flag of Bangladesh (see<br>
<a href="http:">http:</a> // en. wikipedia. org/ wiki/ Gallery_ of_ sovereign- state_ flags).</p>
<ol>
<li>Write a function calleddraw_rectanglethat takes a Canvas and a Rectangle as arguments<br>
and draws a representation of the Rectangle on the Canvas.</li>
<li>Add an attribute namedcolorto your Rectangle objects and modifydraw_rectangleso<br>
that it uses the color attribute as the fill color.</li>
<li>Write a function calleddraw_pointthat takes a Canvas and a Point as arguments and draws<br>
a representation of the Point on the Canvas.</li>
<li>Define a new class called Circle with appropriate attributes and instantiate a few Circle ob-<br>
jects. Write a function calleddraw_circlethat draws circles on the canvas.</li>
<li>Write a program that draws the national flag of the Czech Republic. Hint: you can draw a<br>
polygon like this:</li>
</ol>
<pre><code>points = [[-150,-100], [150, 100], [150, -100]]
canvas.polygon(points, fill='blue')
</code></pre>
<p>I have written a small program that lists the available colors; you can download it fromhttp:<br>
// thinkpython. com/ code/ color_ list. py.</p>
<h2 id="chapter-16">Chapter 16</h2>
<h1 id="classes-and-functions">Classes and functions</h1>
<p>Code examples from this chapter are available fromhttp://thinkpython.com/code/<br>
<a href="http://Time1.py">Time1.py</a>.</p>
<h3 id="time">16.1 Time</h3>
<p>As another example of a user-defined type, we’ll define a class calledTimethat records the<br>
time of day. The class definition looks like this:</p>
<p>class Time(object):<br>
“”"Represents the time of day.</p>
<pre><code>attributes: hour, minute, second
"""
</code></pre>
<p>We can create a newTimeobject and assign attributes for hours, minutes, and seconds:</p>
<p>time = Time()<br>
time.hour = 11<br>
time.minute = 59<br>
time.second = 30</p>
<p>The state diagram for theTimeobject looks like Figure 16.1.<br>
<strong>Exercise 16.1.</strong> Write a function calledprint_timethat takes a Time object and prints it in the<br>
formhour:minute:second. Hint: the format sequence’%.2d’prints an integer using at least<br>
two digits, including a leading zero if necessary.<br>
<strong>Exercise 16.2.</strong> Write a boolean function calledis_afterthat takes two Time objects,t1andt2,<br>
and returnsTrueift1followst2chronologically andFalseotherwise. Challenge: don’t use anif<br>
statement.</p>
<h3 id="pure-functions">16.2 Pure functions</h3>
<p>In the next few sections, we’ll write two functions that add time values. They demonstrate<br>
two kinds of functions: pure functions and modifiers. They also demonstrate a develop-<br>
ment plan I’ll call <strong>prototype and patch</strong> , which is a way of tackling a complex problem by<br>
starting with a simple prototype and incrementally dealing with the complications.</p>
<p><strong>152 Chapter 16. Classes and functions</strong></p>
<pre><code>59
30
</code></pre>
<pre><code>hour
minute
second
</code></pre>
<pre><code>11
</code></pre>
<pre><code>Time
time
</code></pre>
<pre><code>Figure 16.1: Object diagram.
</code></pre>
<p>Here is a simple prototype ofadd_time:</p>
<p>def add_time(t1, t2):<br>
sum = Time()<br>
sum.hour = t1.hour + t2.hour<br>
sum.minute = t1.minute + t2.minute<br>
sum.second = t1.second + t2.second<br>
return sum</p>
<p>The function creates a newTimeobject, initializes its attributes, and returns a reference to<br>
the new object. This is called a <strong>pure function</strong> because it does not modify any of the objects<br>
passed to it as arguments and it has no effect, like displaying a value or getting user input,<br>
other than returning a value.</p>
<p>To test this function, I’ll create two Time objects:startcontains the start time of a movie,<br>
likeMonty Python and the Holy Grail, anddurationcontains the run time of the movie,<br>
which is one hour 35 minutes.</p>
<p>add_timefigures out when the movie will be done.</p>
<blockquote>
<blockquote>
<blockquote>
<p>start = Time()<br>
start.hour = 9<br>
start.minute = 45<br>
start.second = 0</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>duration = Time()<br>
duration.hour = 1<br>
duration.minute = 35<br>
duration.second = 0</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>done = add_time(start, duration)<br>
print_time(done)<br>
10:80:00</p>
</blockquote>
</blockquote>
</blockquote>
<p>The result,10:80:00might not be what you were hoping for. The problem is that this<br>
function does not deal with cases where the number of seconds or minutes adds up to<br>
more than sixty. When that happens, we have to “carry” the extra seconds into the minute<br>
column or the extra minutes into the hour column.</p>
<p>Here’s an improved version:</p>
<p>def add_time(t1, t2):<br>
sum = Time()<br>
sum.hour = t1.hour + t2.hour<br>
sum.minute = t1.minute + t2.minute<br>
sum.second = t1.second + t2.second</p>
<p><strong>16.3. Modifiers 153</strong></p>
<pre><code>if sum.second &gt;= 60:
sum.second -= 60
sum.minute += 1
</code></pre>
<pre><code>if sum.minute &gt;= 60:
sum.minute -= 60
sum.hour += 1
</code></pre>
<pre><code>return sum
</code></pre>
<p>Although this function is correct, it is starting to get big. We will see a shorter alternative<br>
later.</p>
<h3 id="modifiers">16.3 Modifiers</h3>
<p>Sometimes it is useful for a function to modify the objects it gets as parameters. In that case,<br>
the changes are visible to the caller. Functions that work this way are called <strong>modifiers</strong>.</p>
<p>increment, which adds a given number of seconds to aTimeobject, can be written naturally<br>
as a modifier. Here is a rough draft:</p>
<p>def increment(time, seconds):<br>
time.second += seconds</p>
<pre><code>if time.second &gt;= 60:
time.second -= 60
time.minute += 1
</code></pre>
<pre><code>if time.minute &gt;= 60:
time.minute -= 60
time.hour += 1
</code></pre>
<p>The first line performs the basic operation; the remainder deals with the special cases we<br>
saw before.</p>
<p>Is this function correct? What happens if the parametersecondsis much greater than sixty?</p>
<p>In that case, it is not enough to carry once; we have to keep doing it untiltime.secondis<br>
less than sixty. One solution is to replace theifstatements withwhilestatements. That<br>
would make the function correct, but not very efficient.<br>
<strong>Exercise 16.3.</strong> Write a correct version ofincrementthat doesn’t contain any loops.</p>
<p>Anything that can be done with modifiers can also be done with pure functions. In fact,<br>
some programming languages only allow pure functions. There is some evidence that<br>
programs that use pure functions are faster to develop and less error-prone than programs<br>
that use modifiers. But modifiers are convenient at times, and functional programs tend to<br>
be less efficient.</p>
<p>In general, I recommend that you write pure functions whenever it is reasonable and resort<br>
to modifiers only if there is a compelling advantage. This approach might be called a<br>
<strong>functional programming style</strong>.<br>
<strong>Exercise 16.4.</strong> Write a “pure” version ofincrementthat creates and returns a new Time object<br>
rather than modifying the parameter.</p>
<p><strong>154 Chapter 16. Classes and functions</strong></p>
<h3 id="prototyping-versus-planning">16.4 Prototyping versus planning</h3>
<p>The development plan I am demonstrating is called “prototype and patch.” For each func-<br>
tion, I wrote a prototype that performed the basic calculation and then tested it, patching<br>
errors along the way.</p>
<p>This approach can be effective, especially if you don’t yet have a deep understanding<br>
of the problem. But incremental corrections can generate code that is unnecessarily<br>
complicated—since it deals with many special cases—and unreliable—since it is hard to<br>
know if you have found all the errors.</p>
<p>An alternative is <strong>planned development</strong> , in which high-level insight into the problem can<br>
make the programming much easier. In this case, the insight is that a Time object is really<br>
a three-digit number in base 60 (see <a href="http://en.wikipedia.org/wiki/Sexagesimal">http://en.wikipedia.org/wiki/Sexagesimal</a> )! The second attribute is the “ones column,” the minute attribute is the “sixties column,” and the hour attribute is the “thirty-six hundreds column.”</p>
<p>When we wroteadd_timeandincrement, we were effectively doing addition in base 60, which is why we had to carry from one column to the next.</p>
<p>This observation suggests another approach to the whole problem—we can convert Time objects to integers and take advantage of the fact that the computer knows how to do integer arithmetic.</p>
<p>Here is a function that converts Times to integers:</p>
<p>def time_to_int(time):<br>
minutes = time.hour * 60 + time.minute<br>
seconds = minutes * 60 + time.second<br>
return seconds</p>
<p>And here is the function that converts integers to Times (recall thatdivmoddivides the first<br>
argument by the second and returns the quotient and remainder as a tuple).</p>
<p>def int_to_time(seconds):<br>
time = Time()<br>
minutes, time.second = divmod(seconds, 60)<br>
time.hour, time.minute = divmod(minutes, 60)<br>
return time</p>
<p>You might have to think a bit, and run some tests, to convince yourself that these functions<br>
are correct. One way to test them is to check thattime_to_int(int_to_time(x)) == xfor<br>
many values ofx. This is an example of a consistency check.</p>
<p>Once you are convinced they are correct, you can use them to rewriteadd_time:</p>
<p>def add_time(t1, t2):<br>
seconds = time_to_int(t1) + time_to_int(t2)<br>
return int_to_time(seconds)</p>
<p>This version is shorter than the original, and easier to verify.<br>
<strong>Exercise 16.5.</strong> Rewriteincrementusingtime_to_intandint_to_time.</p>
<p>In some ways, converting from base 60 to base 10 and back is harder than just dealing with<br>
times. Base conversion is more abstract; our intuition for dealing with time values is better.</p>
<p>But if we have the insight to treat times as base 60 numbers and make the investment of<br>
writing the conversion functions (time_to_intandint_to_time), we get a program that<br>
is shorter, easier to read and debug, and more reliable.</p>
<p><strong>16.5. Debugging 155</strong></p>
<p>It is also easier to add features later. For example, imagine subtracting two Times to find<br>
the duration between them. The naive approach would be to implement subtraction with<br>
borrowing. Using the conversion functions would be easier and more likely to be correct.</p>
<p>Ironically, sometimes making a problem harder (or more general) makes it easier (because<br>
there are fewer special cases and fewer opportunities for error).</p>
<h3 id="debugging-3">16.5 Debugging</h3>
<p>A Time object is well-formed if the values ofminuteandsecondare between 0 and 60<br>
(including 0 but not 60) and ifhouris positive.hourandminuteshould be integral values,<br>
but we might allowsecondto have a fraction part.</p>
<p>Requirements like these are called <strong>invariants</strong> because they should always be true. To put<br>
it a different way, if they are not true, then something has gone wrong.</p>
<p>Writing code to check your invariants can help you detect errors and find their causes. For<br>
example, you might have a function likevalid_timethat takes a Time object and returns<br>
Falseif it violates an invariant:</p>
<p>def valid_time(time):<br>
if time.hour &lt; 0 or time.minute &lt; 0 or time.second &lt; 0:<br>
return False<br>
if time.minute &gt;= 60 or time.second &gt;= 60:<br>
return False<br>
return True</p>
<p>Then at the beginning of each function you could check the arguments to make sure they<br>
are valid:</p>
<p>def add_time(t1, t2):<br>
if not valid_time(t1) or not valid_time(t2):<br>
raise ValueError(‘invalid Time object in add_time’)<br>
seconds = time_to_int(t1) + time_to_int(t2)<br>
return int_to_time(seconds)</p>
<p>Or you could use anassertstatement, which checks a given invariant and raises an ex-<br>
ception if it fails:</p>
<p>def add_time(t1, t2):<br>
assert valid_time(t1) and valid_time(t2)<br>
seconds = time_to_int(t1) + time_to_int(t2)<br>
return int_to_time(seconds)</p>
<p>assertstatements are useful because they distinguish code that deals with normal condi-<br>
tions from code that checks for errors.</p>
<h3 id="glossary-3">16.6 Glossary</h3>
<p><strong>prototype and patch:</strong> A development plan that involves writing a rough draft of a pro-<br>
gram, testing, and correcting errors as they are found.</p>
<p><strong>planned development:</strong> A development plan that involves high-level insight into the prob-<br>
lem and more planning than incremental development or prototype development.</p>
<p><strong>156 Chapter 16. Classes and functions</strong></p>
<p><strong>pure function:</strong> A function that does not modify any of the objects it receives as arguments.<br>
Most pure functions are fruitful.</p>
<p><strong>modifier:</strong> A function that changes one or more of the objects it receives as arguments. Most<br>
modifiers are fruitless.</p>
<p><strong>functional programming style:</strong> A style of program design in which the majority of func-<br>
tions are pure.</p>
<p><strong>invariant:</strong> A condition that should always be true during the execution of a program.</p>
<h3 id="exercises-4">16.7 Exercises</h3>
<p>Code examples from this chapter are available fromhttp://thinkpython.com/code/<br>
<a href="http://Time1.py">Time1.py</a>; solutions to these exercises are available fromhttp://thinkpython.com/code/<br>
Time1_soln.py.<br>
<strong>Exercise 16.6.</strong> Write a function calledmul_timethat takes a Time object and a number and returns<br>
a new Time object that contains the product of the original Time and the number.</p>
<p>Then usemul_timeto write a function that takes a Time object that represents the finishing time<br>
in a race, and a number that represents the distance, and returns a Time object that represents the<br>
average pace (time per mile).<br>
<strong>Exercise 16.7.</strong> Thedatetimemodule providesdateandtimeobjects that are similar to the Date<br>
and Time objects in this chapter, but they provide a rich set of methods and operators. Read the<br>
documentation athttp: // docs. python. org/ 2/ library/ datetime. html.</p>
<ol>
<li>Use thedatetimemodule to write a program that gets the current date and prints the day of<br>
the week.</li>
<li>Write a program that takes a birthday as input and prints the user’s age and the number of<br>
days, hours, minutes and seconds until their next birthday.</li>
<li>For two people born on different days, there is a day when one is twice as old as the other.<br>
That’s their Double Day. Write a program that takes two birthdays and computes their Double<br>
Day.</li>
<li>For a little more challenge, write the more general version that computes the day when one<br>
person is n times older than the other.</li>
</ol>
<h2 id="chapter-17">Chapter 17</h2>
<h1 id="classes-and-methods">Classes and methods</h1>
<p>Code examples from this chapter are available fromhttp://thinkpython.com/code/<br>
<a href="http://Time2.py">Time2.py</a>.</p>
<h3 id="object-oriented-features">17.1 Object-oriented features</h3>
<p>Python is an <strong>object-oriented programming language</strong> , which means that it provides fea-<br>
tures that support object-oriented programming.</p>
<p>It is not easy to define object-oriented programming, but we have already seen some of its<br>
characteristics:</p>
<ul>
<li>Programs are made up of object definitions and function definitions, and most of the<br>
computation is expressed in terms of operations on objects.</li>
<li>Each object definition corresponds to some object or concept in the real world, and<br>
the functions that operate on that object correspond to the ways real-world objects<br>
interact.</li>
</ul>
<p>For example, theTimeclass defined in Chapter 16 corresponds to the way people record<br>
the time of day, and the functions we defined correspond to the kinds of things people do<br>
with times. Similarly, thePointandRectangleclasses correspond to the mathematical<br>
concepts of a point and a rectangle.</p>
<p>So far, we have not taken advantage of the features Python provides to support object-<br>
oriented programming. These features are not strictly necessary; most of them provide<br>
alternative syntax for things we have already done. But in many cases, the alternative is<br>
more concise and more accurately conveys the structure of the program.</p>
<p>For example, in theTimeprogram, there is no obvious connection between the class defi-<br>
nition and the function definitions that follow. With some examination, it is apparent that<br>
every function takes at least oneTimeobject as an argument.</p>
<p>This observation is the motivation for <strong>methods</strong> ; a method is a function that is associated<br>
with a particular class. We have seen methods for strings, lists, dictionaries and tuples. In<br>
this chapter, we will define methods for user-defined types.</p>
<p>Methods are semantically the same as functions, but there are two syntactic differences:</p>
<p><strong>158 Chapter 17. Classes and methods</strong></p>
<ul>
<li>Methods are defined inside a class definition in order to make the relationship be-<br>
tween the class and the method explicit.</li>
<li>The syntax for invoking a method is different from the syntax for calling a function.</li>
</ul>
<p>In the next few sections, we will take the functions from the previous two chapters and<br>
transform them into methods. This transformation is purely mechanical; you can do it<br>
simply by following a sequence of steps. If you are comfortable converting from one form<br>
to another, you will be able to choose the best form for whatever you are doing.</p>
<h3 id="printing-objects">17.2 Printing objects</h3>
<p>In Chapter 16, we defined a class namedTimeand in Exercise 16.1, you wrote a function<br>
namedprint_time:</p>
<p>class Time(object):<br>
“”“Represents the time of day.”""</p>
<p>def print_time(time):<br>
print ‘%.2d:%.2d:%.2d’ % (time.hour, time.minute, time.second)</p>
<p>To call this function, you have to pass aTimeobject as an argument:</p>
<blockquote>
<blockquote>
<blockquote>
<p>start = Time()<br>
start.hour = 9<br>
start.minute = 45<br>
start.second = 00<br>
print_time(start)<br>
09:45:00</p>
</blockquote>
</blockquote>
</blockquote>
<p>To makeprint_timea method, all we have to do is move the function definition inside the<br>
class definition. Notice the change in indentation.</p>
<p>class Time(object):<br>
def print_time(time):<br>
print ‘%.2d:%.2d:%.2d’ % (time.hour, time.minute, time.second)</p>
<p>Now there are two ways to callprint_time. The first (and less common) way is to use<br>
function syntax:</p>
<blockquote>
<blockquote>
<blockquote>
<p>Time.print_time(start)<br>
09:45:00</p>
</blockquote>
</blockquote>
</blockquote>
<p>In this use of dot notation,Timeis the name of the class, andprint_timeis the name of the<br>
method.startis passed as a parameter.</p>
<p>The second (and more concise) way is to use method syntax:</p>
<blockquote>
<blockquote>
<blockquote>
<p>start.print_time()<br>
09:45:00</p>
</blockquote>
</blockquote>
</blockquote>
<p>In this use of dot notation,print_timeis the name of the method (again), andstartis<br>
the object the method is invoked on, which is called the <strong>subject</strong>. Just as the subject of<br>
a sentence is what the sentence is about, the subject of a method invocation is what the<br>
method is about.</p>
<p>Inside the method, the subject is assigned to the first parameter, so in this casestartis<br>
assigned totime.</p>
<p><strong>17.3. Another example 159</strong></p>
<p>By convention, the first parameter of a method is calledself, so it would be more common<br>
to writeprint_timelike this:</p>
<p>class Time(object):<br>
def print_time(self):<br>
print ‘%.2d:%.2d:%.2d’ % (self.hour, self.minute, self.second)</p>
<p>The reason for this convention is an implicit metaphor:</p>
<ul>
<li>The syntax for a function call,print_time(start), suggests that the function is the<br>
active agent. It says something like, “Heyprint_time! Here’s an object for you to<br>
print.”</li>
<li>In object-oriented programming, the objects are the active agents. A method invoca-<br>
tion likestart.print_time()says “Heystart! Please print yourself.”</li>
</ul>
<p>This change in perspective might be more polite, but it is not obvious that it is useful. In the<br>
examples we have seen so far, it may not be. But sometimes shifting responsibility from the<br>
functions onto the objects makes it possible to write more versatile functions, and makes it<br>
easier to maintain and reuse code.<br>
<strong>Exercise 17.1.</strong> Rewritetime_to_int(from Section 16.4) as a method. It is probably not appro-<br>
priate to rewriteint_to_timeas a method; what object you would invoke it on?</p>
<h3 id="another-example">17.3 Another example</h3>
<p>Here’s a version ofincrement(from Section 16.3) rewritten as a method:</p>
<h1 id="inside-class-time">inside class Time:</h1>
<pre><code>def increment(self, seconds):
seconds += self.time_to_int()
return int_to_time(seconds)
</code></pre>
<p>This version assumes thattime_to_intis written as a method, as in Exercise 17.1. Also,<br>
note that it is a pure function, not a modifier.</p>
<p>Here’s how you would invokeincrement:</p>
<blockquote>
<blockquote>
<blockquote>
<p>start.print_time()<br>
09:45:00</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>end = start.increment(1337)<br>
end.print_time()<br>
10:07:17</p>
</blockquote>
</blockquote>
</blockquote>
<p>The subject,start, gets assigned to the first parameter,self. The argument, 1337 , gets<br>
assigned to the second parameter,seconds.</p>
<p>This mechanism can be confusing, especially if you make an error. For example, if you<br>
invokeincrementwith two arguments, you get:</p>
<blockquote>
<blockquote>
<blockquote>
<p>end = start.increment(1337, 460)<br>
TypeError: increment() takes exactly 2 arguments (3 given)</p>
</blockquote>
</blockquote>
</blockquote>
<p>The error message is initially confusing, because there are only two arguments in paren-<br>
theses. But the subject is also considered an argument, so all together that’s three.</p>
<p><strong>160 Chapter 17. Classes and methods</strong></p>
<h3 id="a-more-complicated-example">17.4 A more complicated example</h3>
<p>is_after(from Exercise 16.2) is slightly more complicated because it takes two Time ob-<br>
jects as parameters. In this case it is conventional to name the first parameterselfand the<br>
second parameterother:</p>
<h1 id="inside-class-time-1">inside class Time:</h1>
<pre><code>def is_after(self, other):
return self.time_to_int() &gt; other.time_to_int()
</code></pre>
<p>To use this method, you have to invoke it on one object and pass the other as an argument:</p>
<blockquote>
<blockquote>
<blockquote>
<p>end.is_after(start)<br>
True</p>
</blockquote>
</blockquote>
</blockquote>
<p>One nice thing about this syntax is that it almost reads like English: “end is after start?”</p>
<h3 id="the-init-method">17.5 The init method</h3>
<p>The init method (short for “initialization”) is a special method that gets invoked when an<br>
object is instantiated. Its full name is__init__(two underscore characters, followed by<br>
init, and then two more underscores). An init method for theTimeclass might look like<br>
this:</p>
<h1 id="inside-class-time-2">inside class Time:</h1>
<pre><code>def __init__(self, hour=0, minute=0, second=0):
self.hour = hour
self.minute = minute
self.second = second
</code></pre>
<p>It is common for the parameters of__init__to have the same names as the attributes. The<br>
statement</p>
<pre><code>self.hour = hour
</code></pre>
<p>stores the value of the parameterhouras an attribute ofself.</p>
<p>The parameters are optional, so if you callTimewith no arguments, you get the default<br>
values.</p>
<blockquote>
<blockquote>
<blockquote>
<p>time = Time()<br>
time.print_time()<br>
00:00:00</p>
</blockquote>
</blockquote>
</blockquote>
<p>If you provide one argument, it overrideshour:</p>
<blockquote>
<blockquote>
<blockquote>
<p>time = Time (9)<br>
time.print_time()<br>
09:00:00</p>
</blockquote>
</blockquote>
</blockquote>
<p>If you provide two arguments, they overridehourandminute.</p>
<blockquote>
<blockquote>
<blockquote>
<p>time = Time(9, 45)<br>
time.print_time()<br>
09:45:00</p>
</blockquote>
</blockquote>
</blockquote>
<p>And if you provide three arguments, they override all three default values.<br>
<strong>Exercise 17.2.</strong> Write an init method for thePointclass that takesxandyas optional parameters<br>
and assigns them to the corresponding attributes.</p>
<p><strong>17.6. The</strong> <strong>str</strong> <strong>method 161</strong></p>
<h3 id="the__str__method">17.6 The__str__method</h3>
<p><strong>str__is a special method, like__init</strong>, that is supposed to return a string representa-<br>
tion of an object.</p>
<p>For example, here is astrmethod for Time objects:</p>
<h1 id="inside-class-time-3">inside class Time:</h1>
<pre><code>def __str__(self):
return '%.2d:%.2d:%.2d' % (self.hour, self.minute, self.second)
</code></pre>
<p>When youprintan object, Python invokes thestrmethod:</p>
<blockquote>
<blockquote>
<blockquote>
<p>time = Time(9, 45)<br>
print time<br>
09:45:00</p>
</blockquote>
</blockquote>
</blockquote>
<p>When I write a new class, I almost always start by writing__init__, which makes it easier<br>
to instantiate objects, and__str__, which is useful for debugging.<br>
<strong>Exercise 17.3.</strong> Write astrmethod for thePointclass. Create a Point object and print it.</p>
<h3 id="operator-overloading">17.7 Operator overloading</h3>
<p>By defining other special methods, you can specify the behavior of operators on user-<br>
defined types. For example, if you define a method named__add__for theTimeclass,<br>
you can use the+operator on Time objects.</p>
<p>Here is what the definition might look like:</p>
<h1 id="inside-class-time-4">inside class Time:</h1>
<pre><code>def __add__(self, other):
seconds = self.time_to_int() + other.time_to_int()
return int_to_time(seconds)
</code></pre>
<p>And here is how you could use it:</p>
<blockquote>
<blockquote>
<blockquote>
<p>start = Time(9, 45)<br>
duration = Time(1, 35)<br>
print start + duration<br>
11:20:00</p>
</blockquote>
</blockquote>
</blockquote>
<p>When you apply the+operator to Time objects, Python invokes__add__. When you print<br>
the result, Python invokes__str__. So there is quite a lot happening behind the scenes!</p>
<p>Changing the behavior of an operator so that it works with user-defined types is called <strong>op-<br>
erator overloading</strong>. For every operator in Python there is a corresponding special method,<br>
like__add__. For more details, seehttp://docs.python.org/2/reference/datamodel.<br>
html#specialnames.<br>
<strong>Exercise 17.4.</strong> Write anaddmethod for the Point class.</p>
<p><strong>162 Chapter 17. Classes and methods</strong></p>
<h3 id="type-based-dispatch">17.8 Type-based dispatch</h3>
<p>In the previous section we added two Time objects, but you also might want to add an<br>
integer to a Time object. The following is a version of__add__that checks the type of<br>
otherand invokes eitheradd_timeorincrement:</p>
<h1 id="inside-class-time-5">inside class Time:</h1>
<pre><code>def __add__(self, other):
if isinstance(other, Time):
return self.add_time(other)
else:
return self.increment(other)
</code></pre>
<pre><code>def add_time(self, other):
seconds = self.time_to_int() + other.time_to_int()
return int_to_time(seconds)
</code></pre>
<pre><code>def increment(self, seconds):
seconds += self.time_to_int()
return int_to_time(seconds)
</code></pre>
<p>The built-in functionisinstancetakes a value and a class object, and returnsTrueif the<br>
value is an instance of the class.</p>
<p>Ifotheris a Time object,__add__invokesadd_time. Otherwise it assumes that the param-<br>
eter is a number and invokesincrement. This operation is called a <strong>type-based dispatch</strong><br>
because it dispatches the computation to different methods based on the type of the argu-<br>
ments.</p>
<p>Here are examples that use the+operator with different types:</p>
<blockquote>
<blockquote>
<blockquote>
<p>start = Time(9, 45)<br>
duration = Time(1, 35)<br>
print start + duration<br>
11:20:00</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>print start + 1337<br>
10:07:17</p>
</blockquote>
</blockquote>
</blockquote>
<p>Unfortunately, this implementation of addition is not commutative. If the integer is the<br>
first operand, you get</p>
<blockquote>
<blockquote>
<blockquote>
<p>print 1337 + start<br>
TypeError: unsupported operand type(s) for +: ‘int’and’instance’</p>
</blockquote>
</blockquote>
</blockquote>
<p>The problem is, instead of asking the Time object to add an integer, Python is asking an<br>
integer to add a Time object, and it doesn’t know how to do that. But there is a clever<br>
solution for this problem: the special method__radd__, which stands for “right-side add.”<br>
This method is invoked when a Time object appears on the right side of the+operator.<br>
Here’s the definition:</p>
<h1 id="inside-class-time-6">inside class Time:</h1>
<pre><code>def __radd__(self, other):
return self.__add__(other)
</code></pre>
<p>And here’s how it’s used:</p>
<p><strong>17.9. Polymorphism 163</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>print 1337 + start<br>
10:07:17<br>
<strong>Exercise 17.5.</strong> Write anaddmethod for Points that works with either a Point object or a tuple:</p>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li>If the second operand is a Point, the method should return a new Point whose x coordinate is<br>
the sum of the x coordinates of the operands, and likewise for the y coordinates.</li>
<li>If the second operand is a tuple, the method should add the first element of the tuple to the x<br>
coordinate and the second element to the y coordinate, and return a new Point with the result.</li>
</ul>
<h3 id="polymorphism">17.9 Polymorphism</h3>
<p>Type-based dispatch is useful when it is necessary, but (fortunately) it is not always neces-<br>
sary. Often you can avoid it by writing functions that work correctly for arguments with<br>
different types.</p>
<p>Many of the functions we wrote for strings will actually work for any kind of sequence.<br>
For example, in Section 11.1 we usedhistogramto count the number of times each letter<br>
appears in a word.</p>
<p>def histogram(s):<br>
d = dict()<br>
for c in s:<br>
if c not in d:<br>
d[c] = 1<br>
else:<br>
d[c] = d[c]+1<br>
return d</p>
<p>This function also works for lists, tuples, and even dictionaries, as long as the elements of<br>
sare hashable, so they can be used as keys ind.</p>
<blockquote>
<blockquote>
<blockquote>
<p>t = [‘spam’,‘egg’,‘spam’, ‘spam’, ‘bacon’, ‘spam’]<br>
histogram(t)<br>
{‘bacon’: 1, ‘egg’: 1,‘spam’: 4}</p>
</blockquote>
</blockquote>
</blockquote>
<p>Functions that can work with several types are called <strong>polymorphic</strong>. Polymorphism can<br>
facilitate code reuse. For example, the built-in functionsum, which adds the elements of a<br>
sequence, works as long as the elements of the sequence support addition.</p>
<p>Since Time objects provide anaddmethod, they work withsum:</p>
<blockquote>
<blockquote>
<blockquote>
<p>t1 = Time(7, 43)<br>
t2 = Time(7, 41)<br>
t3 = Time(7, 37)<br>
total = sum([t1, t2, t3])<br>
print total<br>
23:01:00</p>
</blockquote>
</blockquote>
</blockquote>
<p>In general, if all of the operations inside a function work with a given type, then the func-<br>
tion works with that type.</p>
<p>The best kind of polymorphism is the unintentional kind, where you discover that a func-<br>
tion you already wrote can be applied to a type you never planned for.</p>
<p><strong>164 Chapter 17. Classes and methods</strong></p>
<h3 id="debugging-4">17.10 Debugging</h3>
<p>It is legal to add attributes to objects at any point in the execution of a program, but if you<br>
are a stickler for type theory, it is a dubious practice to have objects of the same type with<br>
different attribute sets. It is usually a good idea to initialize all of an object’s attributes in<br>
the init method.</p>
<p>If you are not sure whether an object has a particular attribute, you can use the built-in<br>
functionhasattr(see Section 15.7).</p>
<p>Another way to access the attributes of an object is through the special attribute__dict__,<br>
which is a dictionary that maps attribute names (as strings) and values:</p>
<blockquote>
<blockquote>
<blockquote>
<p>p = Point(3, 4)<br>
print p.<strong>dict</strong><br>
{‘y’: 4,‘x’: 3}</p>
</blockquote>
</blockquote>
</blockquote>
<p>For purposes of debugging, you might find it useful to keep this function handy:</p>
<p>def print_attributes(obj):<br>
for attr in obj.<strong>dict</strong>:<br>
print attr, getattr(obj, attr)</p>
<p>print_attributestraverses the items in the object’s dictionary and prints each attribute<br>
name and its corresponding value.</p>
<p>The built-in functiongetattrtakes an object and an attribute name (as a string) and returns<br>
the attribute’s value.</p>
<h3 id="interface-and-implementation">17.11 Interface and implementation</h3>
<p>One of the goals of object-oriented design is to make software more maintainable, which<br>
means that you can keep the program working when other parts of the system change, and<br>
modify the program to meet new requirements.</p>
<p>A design principle that helps achieve that goal is to keep interfaces separate from imple-<br>
mentations. For objects, that means that the methods a class provides should not depend<br>
on how the attributes are represented.</p>
<p>For example, in this chapter we developed a class that represents a time of day. Methods<br>
provided by this class includetime_to_int,is_after, andadd_time.</p>
<p>We could implement those methods in several ways. The details of the implementation<br>
depend on how we represent time. In this chapter, the attributes of aTimeobject arehour,<br>
minute, andsecond.</p>
<p>As an alternative, we could replace these attributes with a single integer representing the<br>
number of seconds since midnight. This implementation would make some methods, like<br>
is_after, easier to write, but it makes some methods harder.</p>
<p>After you deploy a new class, you might discover a better implementation. If other parts<br>
of the program are using your class, it might be time-consuming and error-prone to change<br>
the interface.</p>
<p>But if you designed the interface carefully, you can change the implementation without<br>
changing the interface, which means that other parts of the program don’t have to change.</p>
<p><strong>17.12. Glossary 165</strong></p>
<p>Keeping the interface separate from the implementation means that you have to hide the<br>
attributes. Code in other parts of the program (outside the class definition) should use<br>
methods to read and modify the state of the object. They should not access the attributes di-<br>
rectly. This principle is called <strong>information hiding</strong> ; see <a href="http://en.wikipedia.org/wiki/Information_hiding">http://en.wikipedia.org/wiki/Information_hiding</a>.</p>
<p><strong>Exercise 17.6.</strong> Download the code from this chapter ( <a href="http://thinkpython.com/code/Time2">http://thinkpython.com/code/Time2</a>. py ). Change the attributes ofTimeto be a single integer representing seconds since mid-<br>
night. Then modify the methods (and the functionint_to_time) to work with the new implemen-<br>
tation. You should not have to modify the test code inmain. When you are done, the output should<br>
be the same as before. Solution: <a href="http://thinkpython.com/code/Time2_soln.py">http://thinkpython.com/code/Time2_soln.py</a></p>
<h3 id="glossary-4">17.12 Glossary</h3>
<p><strong>object-oriented language:</strong> A language that provides features, such as user-defined classes<br>
and method syntax, that facilitate object-oriented programming.</p>
<p><strong>object-oriented programming:</strong> A style of programming in which data and the operations<br>
that manipulate it are organized into classes and methods.</p>
<p><strong>method:</strong> A function that is defined inside a class definition and is invoked on instances of<br>
that class.</p>
<p><strong>subject:</strong> The object a method is invoked on.</p>
<p><strong>operator overloading:</strong> Changing the behavior of an operator like+so it works with a user-<br>
defined type.</p>
<p><strong>type-based dispatch:</strong> A programming pattern that checks the type of an operand and in-<br>
vokes different functions for different types.</p>
<p><strong>polymorphic:</strong> Pertaining to a function that can work with more than one type.</p>
<p><strong>information hiding:</strong> The principle that the interface provided by an object should not de-<br>
pend on its implementation, in particular the representation of its attributes.</p>
<h3 id="exercises-5">17.13 Exercises</h3>
<p><strong>Exercise 17.7.</strong> This exercise is a cautionary tale about one of the most common, and difficult to<br>
find, errors in Python. Write a definition for a class namedKangaroowith the following methods:</p>
<ol>
<li>An__init__method that initializes an attribute namedpouch_contentsto an empty list.</li>
<li>A method named put_in_pouch that takes an object of any type and adds it to<br>
pouch_contents.</li>
<li>A__str__method that returns a string representation of the Kangaroo object and the con-<br>
tents of the pouch.</li>
</ol>
<p>Test your code by creating twoKangarooobjects, assigning them to variables namedkangaand<br>
roo, and then addingrooto the contents ofkanga’s pouch.</p>
<p><strong>166 Chapter 17. Classes and methods</strong></p>
<p>Downloadhttp: // thinkpython. com/ code/ BadKangaroo. py. It contains a solution to the<br>
previous problem with one big, nasty bug. Find and fix the bug.</p>
<p>If you get stuck, you can downloadhttp: // thinkpython. com/ code/ GoodKangaroo. py,<br>
which explains the problem and demonstrates a solution.<br>
<strong>Exercise 17.8.</strong> Visual is a Python module that provides 3-D graphics. It is not always included<br>
in a Python installation, so you might have to install it from your software repository or, if it’s not<br>
there, fromhttp: // vpython. org.</p>
<p>The following example creates a 3-D space that is 256 units wide, long and high, and sets the<br>
“center” to be the point(128, 128, 128). Then it draws a blue sphere.</p>
<p>from visual import *</p>
<p>scene.range = (256, 256, 256)<br>
scene.center = (128, 128, 128)</p>
<p>color = (0.1, 0.1, 0.9) # mostly blue<br>
sphere(pos=scene.center, radius=128, color=color)</p>
<p>coloris an RGB tuple; that is, the elements are Red-Green-Blue levels between 0.0 and 1.0 (see<br>
<a href="http:">http:</a> // en. wikipedia. org/ wiki/ RGB_ color_ model).</p>
<p>If you run this code, you should see a window with a black background and a blue sphere. If you<br>
drag the middle button up and down, you can zoom in and out. You can also rotate the scene by<br>
dragging the right button, but with only one sphere in the world, it is hard to tell the difference.</p>
<p>The following loop creates a cube of spheres:</p>
<p>t = range(0, 256, 51)<br>
for x in t:<br>
for y in t:<br>
for z in t:<br>
pos = x, y, z<br>
sphere(pos=pos, radius=10, color=color)</p>
<ol>
<li>Put this code in a script and make sure it works for you.</li>
<li>Modify the program so that each sphere in the cube has the color that corresponds to its<br>
position in RGB space. Notice that the coordinates are in the range 0–255, but the RGB<br>
tuples are in the range 0.0–1.0.</li>
<li>Downloadhttp: // thinkpython. com/ code/ color_ list. py and use the function<br>
read_colorsto generate a list of the available colors on your system, their names and RGB<br>
values. For each named color draw a sphere in the position that corresponds to its RGB values.</li>
</ol>
<p>You can see my solution athttp: // thinkpython. com/ code/ color_ space. py.</p>
<h2 id="chapter-18">Chapter 18</h2>
<h1 id="inheritance">Inheritance</h1>
<p>In this chapter I present classes to represent playing cards, decks of cards, and poker hands.<br>
If you don’t play poker, you can read about it at <a href="http://en.wikipedia.org/wiki/Poker">http://en.wikipedia.org/wiki/Poker</a>,<br>
but you don’t have to; I’ll tell you what you need to know for the exercises. Code examples<br>
from this chapter are available fromhttp://thinkpython.com/code/Card.py.</p>
<p>If you are not familiar with Anglo-American playing cards, you can read about them at <a href="http://en.wikipedia.org/wiki/Playing_cards.">http://en.wikipedia.org/wiki/Playing_cards</a>.</p>
<h3 id="card-objects">18.1 Card objects</h3>
<p>There are fifty-two cards in a deck, each of which belongs to one of four suits and one of<br>
thirteen ranks. The suits are Spades, Hearts, Diamonds, and Clubs (in descending order in<br>
bridge). The ranks are Ace, 2, 3, 4, 5, 6, 7, 8, 9, 10, Jack, Queen, and King. Depending on<br>
the game that you are playing, an Ace may be higher than King or lower than 2.</p>
<p>If we want to define a new object to represent a playing card, it is obvious what the at-<br>
tributes should be:rankandsuit. It is not as obvious what type the attributes should be.<br>
One possibility is to use strings containing words like’Spade’for suits and’Queen’for<br>
ranks. One problem with this implementation is that it would not be easy to compare cards<br>
to see which had a higher rank or suit.</p>
<p>An alternative is to use integers to <strong>encode</strong> the ranks and suits. In this context, “encode”<br>
means that we are going to define a mapping between numbers and suits, or between<br>
numbers and ranks. This kind of encoding is not meant to be a secret (that would be<br>
“encryption”).</p>
<p>For example, this table shows the suits and the corresponding integer codes:</p>
<pre><code>Spades 7→ 3
Hearts 7→ 2
Diamonds 7→ 1
Clubs 7→ 0
</code></pre>
<p>This code makes it easy to compare cards; because higher suits map to higher numbers, we<br>
can compare suits by comparing their codes.</p>
<p><strong>168 Chapter 18. Inheritance</strong></p>
<p>The mapping for ranks is fairly obvious; each of the numerical ranks maps to the corre-<br>
sponding integer, and for face cards:</p>
<pre><code>Jack 7→ 11
Queen 7→ 12
King 7→ 13
</code></pre>
<p>I am using the7→symbol to make it clear that these mappings are not part of the Python<br>
program. They are part of the program design, but they don’t appear explicitly in the code.</p>
<p>The class definition forCardlooks like this:</p>
<p>class Card(object):<br>
“”“Represents a standard playing card.”""</p>
<pre><code>def __init__(self, suit=0, rank=2):
self.suit = suit
self.rank = rank
</code></pre>
<p>As usual, the init method takes an optional parameter for each attribute. The default card<br>
is the 2 of Clubs.</p>
<p>To create a Card, you callCardwith the suit and rank of the card you want.</p>
<p>queen_of_diamonds = Card(1, 12)</p>
<h3 id="class-attributes">18.2 Class attributes</h3>
<p>In order to print Card objects in a way that people can easily read, we need a mapping<br>
from the integer codes to the corresponding ranks and suits. A natural way to do that is<br>
with lists of strings. We assign these lists to <strong>class attributes</strong> :</p>
<h1 id="inside-class-card">inside class Card:</h1>
<pre><code>suit_names = ['Clubs', 'Diamonds','Hearts', 'Spades']
rank_names = [None, 'Ace', ' 2 ', ' 3 ', ' 4 ', ' 5 ',' 6 ',' 7 ',
' 8 ', ' 9 ', ' 10 ','Jack','Queen','King']
</code></pre>
<pre><code>def __str__(self):
return '%s of %s'% (Card.rank_names[self.rank],
Card.suit_names[self.suit])
</code></pre>
<p>Variables likesuit_namesandrank_names, which are defined inside a class but outside<br>
of any method, are called class attributes because they are associated with the class object<br>
Card.</p>
<p>This term distinguishes them from variables likesuitandrank, which are called <strong>instance<br>
attributes</strong> because they are associated with a particular instance.</p>
<p>Both kinds of attribute are accessed using dot notation. For example, in__str__,self<br>
is a Card object, and self.rank is its rank. Similarly, Cardis a class object, and<br>
Card.rank_namesis a list of strings associated with the class.</p>
<p>Every card has its ownsuitandrank, but there is only one copy ofsuit_namesand<br>
rank_names.</p>
<p><strong>18.3. Comparing cards 169</strong></p>
<pre><code>list
suit_names
</code></pre>
<pre><code>list
rank_names
</code></pre>
<pre><code>Card
</code></pre>
<pre><code>type
</code></pre>
<pre><code>1
11
</code></pre>
<pre><code>suit
rank
</code></pre>
<pre><code>card1
</code></pre>
<pre><code>Card
</code></pre>
<pre><code>Figure 18.1: Object diagram.
</code></pre>
<p>Putting it all together, the expressionCard.rank_names[self.rank]means “use the at-<br>
tributerankfrom the objectselfas an index into the listrank_namesfrom the classCard,<br>
and select the appropriate string.”</p>
<p>The first element ofrank_namesisNonebecause there is no card with rank zero. By includ-<br>
ingNoneas a place-keeper, we get a mapping with the nice property that the index 2 maps<br>
to the string’ 2 ', and so on. To avoid this tweak, we could have used a dictionary instead<br>
of a list.</p>
<p>With the methods we have so far, we can create and print cards:</p>
<blockquote>
<blockquote>
<blockquote>
<p>card1 = Card(2, 11)<br>
print card1<br>
Jack of Hearts</p>
</blockquote>
</blockquote>
</blockquote>
<p>Figure 18.1 is a diagram of theCardclass object and one Card instance. Cardis a class<br>
object, so it has typetype.card1has typeCard. (To save space, I didn’t draw the contents<br>
ofsuit_namesandrank_names).</p>
<h3 id="comparing-cards">18.3 Comparing cards</h3>
<p>For built-in types, there are relational operators (&lt;,&gt;,==, etc.) that compare values and de-<br>
termine when one is greater than, less than, or equal to another. For user-defined types, we<br>
can override the behavior of the built-in operators by providing a method named__cmp__.</p>
<p>__cmp__takes two parameters,selfandother, and returns a positive number if the first<br>
object is greater, a negative number if the second object is greater, and 0 if they are equal to<br>
each other.</p>
<p>The correct ordering for cards is not obvious. For example, which is better, the 3 of Clubs<br>
or the 2 of Diamonds? One has a higher rank, but the other has a higher suit. In order to<br>
compare cards, you have to decide whether rank or suit is more important.</p>
<p>The answer might depend on what game you are playing, but to keep things simple, we’ll<br>
make the arbitrary choice that suit is more important, so all of the Spades outrank all of the<br>
Diamonds, and so on.</p>
<p>With that decided, we can write__cmp__:</p>
<p><strong>170 Chapter 18. Inheritance</strong></p>
<h1 id="inside-class-card-1">inside class Card:</h1>
<pre><code>def __cmp__(self, other):
# check the suits
if self.suit &gt; other.suit: return 1
if self.suit &lt; other.suit: return -1
</code></pre>
<pre><code># suits are the same... check ranks
if self.rank &gt; other.rank: return 1
if self.rank &lt; other.rank: return -1
</code></pre>
<pre><code># ranks are the same... it's a tie
return 0
</code></pre>
<p>You can write this more concisely using tuple comparison:</p>
<h1 id="inside-class-card-2">inside class Card:</h1>
<pre><code>def __cmp__(self, other):
t1 = self.suit, self.rank
t2 = other.suit, other.rank
return cmp(t1, t2)
</code></pre>
<p>The built-in functioncmphas the same interface as the method__cmp__: it takes two values<br>
and returns a positive number if the first is larger, a negative number if the second is larger,<br>
and 0 if they are equal.</p>
<p>In Python 3,cmpno longer exists, and the__cmp__method is not supported. Instead you<br>
should provide__lt__, which returnsTrueifselfis less thanother. You can implement<br>
__lt__using tuples and the&lt;operator.<br>
<strong>Exercise 18.1.</strong> Write a__cmp__method for Time objects. Hint: you can use tuple comparison, but<br>
you also might consider using integer subtraction.</p>
<h3 id="decks">18.4 Decks</h3>
<p>Now that we have Cards, the next step is to define Decks. Since a deck is made up of cards,<br>
it is natural for each Deck to contain a list of cards as an attribute.</p>
<p>The following is a class definition forDeck. The init method creates the attributecardsand<br>
generates the standard set of fifty-two cards:</p>
<p>class Deck(object):</p>
<pre><code>def __init__(self):
self.cards = []
for suit in range(4):
for rank in range(1, 14):
card = Card(suit, rank)
self.cards.append(card)
</code></pre>
<p>The easiest way to populate the deck is with a nested loop. The outer loop enumerates the<br>
suits from 0 to 3. The inner loop enumerates the ranks from 1 to 13. Each iteration creates<br>
a new Card with the current suit and rank, and appends it toself.cards.</p>
<p><strong>18.5. Printing the deck 171</strong></p>
<h3 id="printing-the-deck">18.5 Printing the deck</h3>
<p>Here is a__str__method forDeck:</p>
<p>#inside class Deck:</p>
<pre><code>def __str__(self):
res = []
for card in self.cards:
res.append(str(card))
return '\n'.join(res)
</code></pre>
<p>This method demonstrates an efficient way to accumulate a large string: building a list of<br>
strings and then usingjoin. The built-in functionstrinvokes the__str__method on each<br>
card and returns the string representation.</p>
<p>Since we invokejoinon a newline character, the cards are separated by newlines. Here’s<br>
what the result looks like:</p>
<blockquote>
<blockquote>
<blockquote>
<p>deck = Deck()<br>
print deck<br>
Ace of Clubs<br>
2 of Clubs<br>
3 of Clubs</p>
</blockquote>
</blockquote>
</blockquote>
<p>10 of Spades<br>
Jack of Spades<br>
Queen of Spades<br>
King of Spades</p>
<p>Even though the result appears on 52 lines, it is one long string that contains newlines.</p>
<h3 id="add-remove-shuffle-and-sort">18.6 Add, remove, shuffle and sort</h3>
<p>To deal cards, we would like a method that removes a card from the deck and returns it.<br>
The list methodpopprovides a convenient way to do that:</p>
<p>#inside class Deck:</p>
<pre><code>def pop_card(self):
return self.cards.pop()
</code></pre>
<p>Sincepopremoves thelastcard in the list, we are dealing from the bottom of the deck. In<br>
real life “bottom dealing” is frowned upon, but in this context it’s ok.</p>
<p>To add a card, we can use the list methodappend:</p>
<p>#inside class Deck:</p>
<pre><code>def add_card(self, card):
self.cards.append(card)
</code></pre>
<p>A method like this that uses another function without doing much real work is sometimes<br>
called a <strong>veneer</strong>. The metaphor comes from woodworking, where it is common to glue a<br>
thin layer of good quality wood to the surface of a cheaper piece of wood.</p>
<p><strong>172 Chapter 18. Inheritance</strong></p>
<p>In this case we are defining a “thin” method that expresses a list operation in terms that are<br>
appropriate for decks.</p>
<p>As another example, we can write a Deck method namedshuffleusing the function<br>
shufflefrom therandommodule:</p>
<h1 id="inside-class-deck">inside class Deck:</h1>
<pre><code>def shuffle(self):
random.shuffle(self.cards)
</code></pre>
<p>Don’t forget to importrandom.<br>
<strong>Exercise 18.2.</strong> Write a Deck method namedsortthat uses the list methodsortto sort the cards<br>
in aDeck.sortuses the__cmp__method we defined to determine sort order.</p>
<h3 id="inheritance-1">18.7 Inheritance</h3>
<p>The language feature most often associated with object-oriented programming is <strong>inher-<br>
itance</strong>. Inheritance is the ability to define a new class that is a modified version of an<br>
existing class.</p>
<p>It is called “inheritance” because the new class inherits the methods of the existing class.<br>
Extending this metaphor, the existing class is called the <strong>parent</strong> and the new class is called<br>
the <strong>child</strong>.</p>
<p>As an example, let’s say we want a class to represent a “hand,” that is, the set of cards held<br>
by one player. A hand is similar to a deck: both are made up of a set of cards, and both<br>
require operations like adding and removing cards.</p>
<p>A hand is also different from a deck; there are operations we want for hands that don’t<br>
make sense for a deck. For example, in poker we might compare two hands to see which<br>
one wins. In bridge, we might compute a score for a hand in order to make a bid.</p>
<p>This relationship between classes—similar, but different—lends itself to inheritance.</p>
<p>The definition of a child class is like other class definitions, but the name of the parent class<br>
appears in parentheses:</p>
<p>class Hand(Deck):<br>
“”“Represents a hand of playing cards.”""</p>
<p>This definition indicates thatHandinherits fromDeck; that means we can use methods like<br>
pop_cardandadd_cardfor Hands as well as Decks.</p>
<p>Handalso inherits__init__fromDeck, but it doesn’t really do what we want: instead of<br>
populating the hand with 52 new cards, the init method for Hands should initializecards<br>
with an empty list.</p>
<p>If we provide an init method in theHandclass, it overrides the one in theDeckclass:</p>
<h1 id="inside-class-hand">inside class Hand:</h1>
<pre><code>def __init__(self, label=''):
self.cards = []
self.label = label
</code></pre>
<p><strong>18.8. Class diagrams 173</strong></p>
<p>So when you create a Hand, Python invokes this init method:</p>
<blockquote>
<blockquote>
<blockquote>
<p>hand = Hand(‘new hand’)<br>
print hand.cards<br>
[]</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>print hand.label<br>
new hand</p>
</blockquote>
</blockquote>
</blockquote>
<p>But the other methods are inherited fromDeck, so we can usepop_cardandadd_cardto<br>
deal a card:</p>
<blockquote>
<blockquote>
<blockquote>
<p>deck = Deck()<br>
card = deck.pop_card()<br>
hand.add_card(card)<br>
print hand<br>
King of Spades</p>
</blockquote>
</blockquote>
</blockquote>
<p>A natural next step is to encapsulate this code in a method calledmove_cards:</p>
<p>#inside class Deck:</p>
<pre><code>def move_cards(self, hand, num):
for i in range(num):
hand.add_card(self.pop_card())
</code></pre>
<p>move_cardstakes two arguments, a Hand object and the number of cards to deal. It modi-<br>
fies bothselfandhand, and returnsNone.</p>
<p>In some games, cards are moved from one hand to another, or from a hand back to the<br>
deck. You can usemove_cardsfor any of these operations:selfcan be either a Deck or a<br>
Hand, andhand, despite the name, can also be aDeck.<br>
<strong>Exercise 18.3.</strong> Write a Deck method calleddeal_handsthat takes two parameters, the number of<br>
hands and the number of cards per hand, and that creates new Hand objects, deals the appropriate<br>
number of cards per hand, and returns a list of Hand objects.</p>
<p>Inheritance is a useful feature. Some programs that would be repetitive without inheritance<br>
can be written more elegantly with it. Inheritance can facilitate code reuse, since you can<br>
customize the behavior of parent classes without having to modify them. In some cases,<br>
the inheritance structure reflects the natural structure of the problem, which makes the<br>
program easier to understand.</p>
<p>On the other hand, inheritance can make programs difficult to read. When a method is<br>
invoked, it is sometimes not clear where to find its definition. The relevant code may<br>
be scattered among several modules. Also, many of the things that can be done using<br>
inheritance can be done as well or better without it.</p>
<h3 id="class-diagrams">18.8 Class diagrams</h3>
<p>So far we have seen stack diagrams, which show the state of a program, and object dia-<br>
grams, which show the attributes of an object and their values. These diagrams represent<br>
a snapshot in the execution of a program, so they change as the program runs.</p>
<p>They are also highly detailed; for some purposes, too detailed. A class diagram is a more<br>
abstract representation of the structure of a program. Instead of showing individual ob-<br>
jects, it shows classes and the relationships between them.</p>
<p><strong>174 Chapter 18. Inheritance</strong></p>
<pre><code>Hand
</code></pre>
<pre><code>Deck * Card
</code></pre>
<pre><code>Figure 18.2: Class diagram.
</code></pre>
<p>There are several kinds of relationship between classes:</p>
<ul>
<li>Objects in one class might contain references to objects in another class. For example,<br>
each Rectangle contains a reference to a Point, and each Deck contains references to<br>
many Cards. This kind of relationship is called <strong>HAS-A</strong> , as in, “a Rectangle has a<br>
Point.”</li>
<li>One class might inherit from another. This relationship is called <strong>IS-A</strong> , as in, “a Hand<br>
is a kind of a Deck.”</li>
<li>One class might depend on another in the sense that changes in one class would<br>
require changes in the other.</li>
</ul>
<p>A <strong>class diagram</strong> is a graphical representation of these relationships. For example, Fig-<br>
ure 18.2 shows the relationships betweenCard,DeckandHand.</p>
<p>The arrow with a hollow triangle head represents an IS-A relationship; in this case it indi-<br>
cates that Hand inherits from Deck.</p>
<p>The standard arrow head represents a HAS-A relationship; in this case a Deck has refer-<br>
ences to Card objects.</p>
<p>The star (*) near the arrow head is a <strong>multiplicity</strong> ; it indicates how many Cards a Deck has.<br>
A multiplicity can be a simple number, like 52 , a range, like5…7or a star, which indicates<br>
that a Deck can have any number of Cards.</p>
<p>A more detailed diagram might show that a Deck actually contains alistof Cards, but<br>
built-in types like list and dict are usually not included in class diagrams.<br>
<strong>Exercise 18.4.</strong> <a href="http://ReadTurtleWorld.py">ReadTurtleWorld.py</a>,World.pyandGui.pyand draw a class diagram that<br>
shows the relationships among the classes defined there.</p>
<h3 id="debugging-5">18.9 Debugging</h3>
<p>Inheritance can make debugging a challenge because when you invoke a method on an<br>
object, you might not know which method will be invoked.</p>
<p>Suppose you are writing a function that works with Hand objects. You would like it to<br>
work with all kinds of Hands, like PokerHands, BridgeHands, etc. If you invoke a method<br>
likeshuffle, you might get the one defined inDeck, but if any of the subclasses override<br>
this method, you’ll get that version instead.</p>
<p>Any time you are unsure about the flow of execution through your program, the sim-<br>
plest solution is to add print statements at the beginning of the relevant methods. If</p>
<p><strong>18.10. Data encapsulation 175</strong></p>
<p>Deck.shuffleprints a message that says something likeRunning Deck.shuffle, then as<br>
the program runs it traces the flow of execution.</p>
<p>As an alternative, you could use this function, which takes an object and a method name<br>
(as a string) and returns the class that provides the definition of the method:</p>
<p>def find_defining_class(obj, meth_name):<br>
for ty in type(obj).mro():<br>
if meth_name in ty.<strong>dict</strong>:<br>
return ty</p>
<p>Here’s an example:</p>
<blockquote>
<blockquote>
<blockquote>
<p>hand = Hand()<br>
print find_defining_class(hand,‘shuffle’)<br>
&lt;class’Card.Deck’&gt;</p>
</blockquote>
</blockquote>
</blockquote>
<p>So theshufflemethod for this Hand is the one inDeck.</p>
<p>find_defining_classuses themromethod to get the list of class objects (types) that will<br>
be searched for methods. “MRO” stands for “method resolution order.”</p>
<p>Here’s a program design suggestion: whenever you override a method, the interface of the<br>
new method should be the same as the old. It should take the same parameters, return the<br>
same type, and obey the same preconditions and postconditions. If you obey this rule, you<br>
will find that any function designed to work with an instance of a superclass, like a Deck,<br>
will also work with instances of subclasses like a Hand or PokerHand.</p>
<p>If you violate this rule, your code will collapse like (sorry) a house of cards.</p>
<h3 id="data-encapsulation">18.10 Data encapsulation</h3>
<p>Chapter 16 demonstrates a development plan we might call “object-oriented design.” We<br>
identified objects we needed—Time,PointandRectangle—and defined classes to repre-<br>
sent them. In each case there is an obvious correspondence between the object and some<br>
entity in the real world (or at least a mathematical world).</p>
<p>But sometimes it is less obvious what objects you need and how they should interact. In<br>
that case you need a different development plan. In the same way that we discovered<br>
function interfaces by encapsulation and generalization, we can discover class interfaces<br>
by <strong>data encapsulation</strong>.</p>
<p>Markov analysis, from Section 13.8, provides a good example. If you download my<br>
code fromhttp://thinkpython.com/code/markov.py, you’ll see that it uses two global<br>
variables—suffix_mapandprefix—that are read and written from several functions.</p>
<p>suffix_map = {}<br>
prefix = ()</p>
<p>Because these variables are global we can only run one analysis at a time. If we read two<br>
texts, their prefixes and suffixes would be added to the same data structures (which makes<br>
for some interesting generated text).</p>
<p>To run multiple analyses, and keep them separate, we can encapsulate the state of each<br>
analysis in an object. Here’s what that looks like:</p>
<p><strong>176 Chapter 18. Inheritance</strong></p>
<p>class Markov(object):</p>
<pre><code>def __init__(self):
self.suffix_map = {}
self.prefix = ()
</code></pre>
<p>Next, we transform the functions into methods. For example, here’sprocess_word:</p>
<pre><code>def process_word(self, word, order=2):
if len(self.prefix) &lt; order:
self.prefix += (word,)
return
</code></pre>
<pre><code>try:
self.suffix_map[self.prefix].append(word)
except KeyError:
# if there is no entry for this prefix, make one
self.suffix_map[self.prefix] = [word]
</code></pre>
<pre><code>self.prefix = shift(self.prefix, word)
</code></pre>
<p>Transforming a program like this—changing the design without changing the function—is<br>
another example of refactoring (see Section 4.7).</p>
<p>This example suggests a development plan for designing objects and methods:</p>
<ol>
<li>Start by writing functions that read and write global variables (when necessary).</li>
<li>Once you get the program working, look for associations between global variables<br>
and the functions that use them.</li>
<li>Encapsulate related variables as attributes of an object.</li>
<li>Transform the associated functions into methods of the new class.</li>
</ol>
<p><strong>Exercise 18.5.</strong> Download my code from Section 13.8 (http: // thinkpython. com/ code/<br>
markov. py), and follow the steps described above to encapsulate the global variables as attributes<br>
of a new class calledMarkov. Solution:http: // thinkpython. com/ code/ Markov. py(note<br>
the capital M).</p>
<h3 id="glossary-5">18.11 Glossary</h3>
<p><strong>encode:</strong> To represent one set of values using another set of values by constructing a map-<br>
ping between them.</p>
<p><strong>class attribute:</strong> An attribute associated with a class object. Class attributes are defined<br>
inside a class definition but outside any method.</p>
<p><strong>instance attribute:</strong> An attribute associated with an instance of a class.</p>
<p><strong>veneer:</strong> A method or function that provides a different interface to another function with-<br>
out doing much computation.</p>
<p><strong>inheritance:</strong> The ability to define a new class that is a modified version of a previously<br>
defined class.</p>
<p><strong>18.12. Exercises 177</strong></p>
<p><strong>parent class:</strong> The class from which a child class inherits.</p>
<p><strong>child class:</strong> A new class created by inheriting from an existing class; also called a “sub-<br>
class.”</p>
<p><strong>IS-A relationship:</strong> The relationship between a child class and its parent class.</p>
<p><strong>HAS-A relationship:</strong> The relationship between two classes where instances of one class<br>
contain references to instances of the other.</p>
<p><strong>class diagram:</strong> A diagram that shows the classes in a program and the relationships be-<br>
tween them.</p>
<p><strong>multiplicity:</strong> A notation in a class diagram that shows, for a HAS-A relationship, how<br>
many references there are to instances of another class.</p>
<h3 id="exercises-6">18.12 Exercises</h3>
<p><strong>Exercise 18.6.</strong> The following are the possible hands in poker, in increasing order of value (and<br>
decreasing order of probability):</p>
<p><strong>pair:</strong> two cards with the same rank</p>
<p><strong>two pair:</strong> two pairs of cards with the same rank</p>
<p><strong>three of a kind:</strong> three cards with the same rank</p>
<p><strong>straight:</strong> five cards with ranks in sequence (aces can be high or low, soAce-2-3-4-5is a straight<br>
and so is10-Jack-Queen-King-Ace, butQueen-King-Ace-2-3is not.)</p>
<p><strong>flush:</strong> five cards with the same suit</p>
<p><strong>full house:</strong> three cards with one rank, two cards with another</p>
<p><strong>four of a kind:</strong> four cards with the same rank</p>
<p><strong>straight flush:</strong> five cards in sequence (as defined above) and with the same suit</p>
<p>The goal of these exercises is to estimate the probability of drawing these various hands.</p>
<ol>
<li>Download the following files fromhttp: // thinkpython. com/ code:<br>
<a href="http://Card.py">Card.py</a>: A complete version of theCard,DeckandHandclasses in this chapter.<br>
<a href="http://PokerHand.py">PokerHand.py</a>: An incomplete implementation of a class that represents a poker hand, and<br>
some code that tests it.</li>
<li>If you <a href="http://runPokerHand.py">runPokerHand.py</a>, it deals seven 7-card poker hands and checks to see if any of them<br>
contains a flush. Read this code carefully before you go on.</li>
<li>Add methods toPokerHand.pynamedhas_pair,has_twopair, etc. that return True or<br>
False according to whether or not the hand meets the relevant criteria. Your code should<br>
work correctly for “hands” that contain any number of cards (although 5 and 7 are the most<br>
common sizes).</li>
<li>Write a method namedclassifythat figures out the highest-value classification for a hand<br>
and sets thelabelattribute accordingly. For example, a 7-card hand might contain a flush<br>
and a pair; it should be labeled “flush”.</li>
</ol>
<p><strong>178 Chapter 18. Inheritance</strong></p>
<ol start="5">
<li>When you are convinced that your classification methods are working, the next step is to esti-<br>
mate the probabilities of the various hands. Write a function inPokerHand.pythat shuffles<br>
a deck of cards, divides it into hands, classifies the hands, and counts the number of times<br>
various classifications appear.</li>
<li>Print a table of the classifications and their probabilities. Run your program with larger and<br>
larger numbers of hands until the output values converge to a reasonable degree of accu-<br>
racy. Compare your results to the values athttp: // en. wikipedia. org/ wiki/ Hand_<br>
rankings.</li>
</ol>
<p>Solution:http: // thinkpython. com/ code/ PokerHandSoln. py.<br>
<strong>Exercise 18.7.</strong> This exercise uses TurtleWorld from Chapter 4. You will write code that makes<br>
Turtles play tag. If you are not familiar with the rules of tag, seehttp: // en. wikipedia. org/<br>
wiki/ Tag_ ( game).</p>
<ol>
<li>Downloadhttp: // thinkpython. com/ code/ Wobbler. pyand run it. You should see a<br>
TurtleWorld with three Turtles. If you press theRunbutton, the Turtles wander at random.</li>
<li>Read the code and make sure you understand how it works. TheWobblerclass inherits from<br>
Turtle, which means that theTurtlemethodslt,rt,fdandbkwork on Wobblers.<br>
Thestepmethod gets invoked by TurtleWorld. It invokessteer, which turns the Turtle<br>
in the desired direction,wobble, which makes a random turn in proportion to the Turtle’s<br>
clumsiness, andmove, which moves forward a few pixels, depending on the Turtle’s speed.</li>
<li>Create a file <a href="http://namedTagger.py">namedTagger.py</a>. Import everything fromWobbler, then define a class named<br>
Taggerthat inherits fromWobbler. Callmake_worldpassing theTaggerclass object as an<br>
argument.</li>
<li>Add asteermethod toTaggerto override the one inWobbler. As a starting place, write a<br>
version that always points the Turtle toward the origin. Hint: use the math functionatan2<br>
and the Turtle attributesx,yandheading.</li>
<li>Modifysteerso that the Turtles stay in bounds. For debugging, you might want to use the<br>
Stepbutton, which invokessteponce on each Turtle.</li>
<li>Modifysteerso that each Turtle points toward its nearest neighbor. Hint: Turtles have an<br>
attribute,world, that is a reference to the TurtleWorld they live in, and the TurtleWorld has<br>
an attribute,animals, that is a list of all Turtles in the world.</li>
<li>Modifysteerso the Turtles play tag. You can add methods toTaggerand you can override<br>
steerand__init__, but you may not modify or overridestep,wobbleormove. Also,<br>
steeris allowed to change the heading of the Turtle but not the position.<br>
Adjust the rules and yoursteermethod for good quality play; for example, it should be<br>
possible for the slow Turtle to tag the faster Turtles eventually.</li>
</ol>
<p>Solution:http: // thinkpython. com/ code/ Tagger. py.</p>
<h2 id="chapter-19">Chapter 19</h2>
<h1 id="case-study-tkinter">Case study: Tkinter</h1>
<h2 id="gui">19.1 GUI</h2>
<p>Most of the programs we have seen so far are text-based, but many programs use <strong>graphical<br>
user interfaces</strong> , also known as <strong>GUIs</strong>.</p>
<p>Python provides several choices for writing GUI-based programs, including wxPython,<br>
Tkinter, and Qt. Each has pros and cons, which is why Python has not converged on a<br>
standard.</p>
<p>The one I will present in this chapter is Tkinter because I think it is the easiest to get started<br>
with. Most of the concepts in this chapter apply to the other GUI modules, too.</p>
<p>There are several books and web pages about Tkinter. One of the best online resources is<br>
An Introduction to Tkinterby Fredrik Lundh.</p>
<p>I have written a module calledGui.pythat comes with Swampy. It provides a simplified<br>
interface to the functions and classes in Tkinter. The examples in this chapter are based on<br>
this module.</p>
<p>Here is a simple example that creates and displays a Gui:</p>
<p>To create a GUI, you have to importGuifrom Swampy:</p>
<p>from swampy.Gui import *</p>
<p>Or, depending on how you installed Swampy, like this:</p>
<p>from Gui import *</p>
<p>Then instantiate a Gui object:</p>
<p>g = Gui()<br>
g.title(‘Gui’)<br>
g.mainloop()</p>
<p>When you run this code, a window should appear with an empty gray square and the<br>
titleGui. mainloopruns the <strong>event loop</strong> , which waits for the user to do something and</p>
<p><strong>180 Chapter 19. Case study: Tkinter</strong></p>
<p>responds accordingly. It is an infinite loop; it runs until the user closes the window, or<br>
presses Control-C, or does something that causes the program to quit.</p>
<p>This Gui doesn’t do much because it doesn’t have any <strong>widgets</strong>. Widgets are the elements<br>
that make up a GUI; they include:</p>
<p><strong>Button:</strong> A widget, containing text or an image, that performs an action when pressed.</p>
<p><strong>Canvas:</strong> A region that can display lines, rectangles, circles and other shapes.</p>
<p><strong>Entry:</strong> A region where users can type text.</p>
<p><strong>Scrollbar:</strong> A widget that controls the visible part of another widget.</p>
<p><strong>Frame:</strong> A container, often invisible, that contains other widgets.</p>
<p>The empty gray square you see when you create a Gui is a Frame. When you create a new<br>
widget, it is added to this Frame.</p>
<h3 id="buttons-and-callbacks">19.2 Buttons and callbacks</h3>
<p>The methodbucreates a Button widget:</p>
<p>button = g.bu(text=‘Press me.’)</p>
<p>The return value frombuis a Button object. The button that appears in the Frame is a<br>
graphical representation of this object; you can control the button by invoking methods on<br>
it.</p>
<p>butakes up to 32 parameters that control the appearance and function of the button. These<br>
parameters are called <strong>options</strong>. Instead of providing values for all 32 options, you can use<br>
keyword arguments, liketext=‘Press me.’, to specify only the options you need and use<br>
the default values for the rest.</p>
<p>When you add a widget to the Frame, it gets “shrink-wrapped;” that is, the Frame shrinks<br>
to the size of the Button. If you add more widgets, the Frame grows to accommodate them.</p>
<p>The methodlacreates a Label widget:</p>
<p>label = <a href="http://g.la">g.la</a>(text=‘Press the button.’)</p>
<p>By default, Tkinter stacks the widgets top-to-bottom and centers them. We’ll see how to<br>
override that behavior soon.</p>
<p>If you press the button, you will see that it doesn’t do much. That’s because you haven’t<br>
“wired it up;” that is, you haven’t told it what to do!</p>
<p>The option that controls the behavior of a button iscommand. The value ofcommandis a<br>
function that gets executed when the button is pressed. For example, here is a function<br>
that creates a new Label:</p>
<p>def make_label():<br>
<a href="http://g.la">g.la</a>(text=‘Thank you.’)</p>
<p>Now we can create a button with this function as its command:</p>
<p><strong>19.3. Canvas widgets 181</strong></p>
<p>button2 = g.bu(text=‘No, press me!’, command=make_label)</p>
<p>When you press this button, it should executemake_labeland a new label should appear.</p>
<p>The value of thecommandoption is a function object, which is known as a <strong>callback</strong> because<br>
after you callbuto create the button, the flow of execution “calls back” when the user<br>
presses the button.</p>
<p>This kind of flow is characteristic of <strong>event-driven programming</strong>. User actions, like but-<br>
ton presses and key strokes, are called <strong>events</strong>. In event-driven programming, the flow of<br>
execution is determined by user actions rather than by the programmer.</p>
<p>The challenge of event-driven programming is to construct a set of widgets and callbacks<br>
that work correctly (or at least generate appropriate error messages) for any sequence of<br>
user actions.<br>
<strong>Exercise 19.1.</strong> Write a program that creates a GUI with a single button. When the button is<br>
pressed it should create a second button. Whenthatbutton is pressed, it should create a label that<br>
says, “Nice job!”.</p>
<p>What happens if you press the buttons more than once? Solution:http: // thinkpython. com/<br>
code/ button_ demo. py</p>
<h3 id="canvas-widgets">19.3 Canvas widgets</h3>
<p>One of the most versatile widgets is the Canvas, which creates a region for drawing lines,<br>
circles and other shapes. If you did Exercise 15.4 you are already familiar with canvases.</p>
<p>The methodcacreates a new Canvas:</p>
<p>canvas = <a href="http://g.ca">g.ca</a>(width=500, height=500)</p>
<p>widthandheightare the dimensions of the canvas in pixels.</p>
<p>After you create a widget, you can still change the values of the options with theconfig<br>
method. For example, thebgoption changes the background color:</p>
<p>canvas.config(bg=‘white’)</p>
<p>The value ofbgis a string that names a color. The set of legal color names is different for<br>
different implementations of Python, but all implementations provide at least:</p>
<p>white black<br>
red green blue<br>
cyan yellow magenta</p>
<p>Shapes on a Canvas are called <strong>items</strong>. For example, the Canvas methodcircledraws (you<br>
guessed it) a circle:</p>
<p>item = canvas.circle([0,0], 100, fill=‘red’)</p>
<p>The first argument is a coordinate pair that specifies the center of the circle; the second is<br>
the radius.</p>
<p>Gui.pyprovides a standard Cartesian coordinate system with the origin at the center of<br>
the Canvas and the positiveyaxis pointing up. This is different from some other graphics<br>
systems where the origin is in the upper left corner, with theyaxis pointing down.</p>
<p>Thefilloption specifies that the circle should be filled in with red.</p>
<p>The return value fromcircleis an Item object that provides methods for modifying the<br>
item on the canvas. For example, you can useconfigto change any of the circle’s options:</p>
<p><strong>182 Chapter 19. Case study: Tkinter</strong></p>
<p>item.config(fill=‘yellow’, outline=‘orange’, width=10)</p>
<p>widthis the thickness of the outline in pixels;outlineis the color.<br>
<strong>Exercise 19.2.</strong> Write a program that creates a Canvas and a Button. When the user presses the<br>
Button, it should draw a circle on the canvas.</p>
<h3 id="coordinate-sequences">19.4 Coordinate sequences</h3>
<p>Therectanglemethod takes a sequence of coordinates that specify opposite corners of the<br>
rectangle. This example draws a blue rectangle with the lower left corner at the origin and<br>
the upper right corner at(200, 100):</p>
<p>canvas.rectangle([[0, 0], [200, 100]],<br>
fill=‘blue’, outline=‘orange’, width=10)</p>
<p>This way of specifying corners is called a <strong>bounding box</strong> because the two points bound the<br>
rectangle.</p>
<p>ovaltakes a bounding box and draws an oval within the specified rectangle:</p>
<p>canvas.oval([[0, 0], [200, 100]], outline=‘orange’, width=10)</p>
<p>linetakes a sequence of coordinates and draws a line that connects the points. This exam-<br>
ple draws two legs of a triangle:</p>
<p>canvas.line([[0, 100], [100, 200], [200, 100]], width=10)</p>
<p>polygontakes the same arguments, but it draws the last leg of the polygon (if necessary)<br>
and fills it in:</p>
<p>canvas.polygon([[0, 100], [100, 200], [200, 100]],<br>
fill=‘red’, outline=‘orange’, width=10)</p>
<h3 id="more-widgets">19.5 More widgets</h3>
<p>Tkinter provides two widgets that let users type text: an Entry, which is a single line, and<br>
a Text widget, which has multiple lines.</p>
<p>encreates a new Entry:</p>
<p>entry = g.en(text=‘Default text.’)</p>
<p>Thetextoption allows you to put text into the entry when it is created. Thegetmethod<br>
returns the contents of the Entry (which may have been changed by the user):</p>
<blockquote>
<blockquote>
<blockquote>
<p>entry.get()<br>
‘Default text.’</p>
</blockquote>
</blockquote>
</blockquote>
<p>tecreates a Text widget:</p>
<p>text = g.te(width=100, height=5)</p>
<p>widthandheightare the dimensions of the widget in characters and lines.</p>
<p>insertputs text into the Text widget:</p>
<p>text.insert(END,‘A line of text.’)</p>
<p><strong>19.6. Packing widgets 183</strong></p>
<p>ENDis a special index that indicates the last character in the Text widget.</p>
<p>You can also specify a character using a dotted index, like1.1, which has the line num-<br>
ber before the dot and the column number after. The following example adds the letters<br>
'nother’after the first character of the first line.</p>
<blockquote>
<blockquote>
<blockquote>
<p>text.insert(1.1,‘nother’)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Thegetmethod reads the text in the widget; it takes a start and end index as arguments.<br>
The following example returns all the text in the widget, including the newline character:</p>
<blockquote>
<blockquote>
<blockquote>
<p>text.get(0.0, END)<br>
‘Another line of text.\n’</p>
</blockquote>
</blockquote>
</blockquote>
<p>Thedeletemethod removes text from the widget; the following example deletes all but<br>
the first two characters:</p>
<blockquote>
<blockquote>
<blockquote>
<p>text.delete(1.2, END)<br>
text.get(0.0, END)<br>
‘An\n’<br>
<strong>Exercise 19.3.</strong> Modify your solution to Exercise 19.2 by adding an Entry widget and a second<br>
button. When the user presses the second button, it should read a color name from the Entry and<br>
use it to change the fill color of the circle. Useconfigto modify the existing circle; don’t create a<br>
new one.</p>
</blockquote>
</blockquote>
</blockquote>
<p>Your program should handle the case where the user tries to change the color of a circle that hasn’t<br>
been created, and the case where the color name is invalid.</p>
<p>You can see my solution athttp: // thinkpython. com/ code/ circle_ demo. py.</p>
<h3 id="packing-widgets">19.6 Packing widgets</h3>
<p>So far we have been stacking widgets in a single column, but in most GUIs the layout is<br>
more complicated. For example, Figure 19.1 shows a simplified version of TurtleWorld (see<br>
Chapter 4).</p>
<p>This section presents the code that creates this GUI, broken into a series of<br>
steps. You can download the complete example fromhttp://thinkpython.com/code/<br>
<a href="http://SimpleTurtleWorld.py">SimpleTurtleWorld.py</a>.</p>
<p>At the top level, this GUI contains two widgets—a Canvas and a Frame—arranged in a<br>
row. So the first step is to create the row.</p>
<p>class SimpleTurtleWorld(TurtleWorld):<br>
“”“This class is identical to TurtleWorld, but the code that<br>
lays out the GUI is simplified for explanatory purposes.”""</p>
<pre><code>def setup(self):
self.row()
...
</code></pre>
<p>setupis the function that creates and arranges the widgets. Arranging widgets in a GUI is<br>
called <strong>packing</strong>.</p>
<p>rowcreates a row Frame and makes it the “current Frame.” Until this Frame is closed or<br>
another Frame is created, all subsequent widgets are packed in a row.</p>
<p>Here is the code that creates the Canvas and the column Frame that hold the other widgets:</p>
<p><strong>184 Chapter 19. Case study: Tkinter</strong></p>
<pre><code>Figure 19.1: TurtleWorld after running the snowflake code.
</code></pre>
<pre><code>self.canvas = self.ca(width=400, height=400, bg='white')
self.col()
</code></pre>
<p>The first widget in the column is a grid Frame, which contains four buttons arranged two-<br>
by-two:</p>
<pre><code>self.gr(cols=2)
self.bu(text='Print canvas', command=self.canvas.dump)
self.bu(text='Quit', command=self.quit)
self.bu(text='Make Turtle', command=self.make_turtle)
self.bu(text='Clear', command=self.clear)
self.endgr()
</code></pre>
<p>grcreates the grid; the argument is the number of columns. Widgets in the grid are laid<br>
out left-to-right, top-to-bottom.</p>
<p>The first button usesself.canvas.dumpas a callback; the second usesself.quit. These<br>
are <strong>bound methods</strong> , which means they are associated with a particular object. When they<br>
are invoked, they are invoked on the object.</p>
<p>The next widget in the column is a row Frame that contains a Button and an Entry:</p>
<pre><code>self.row([0,1], pady=30)
self.bu(text='Run file', command=self.run_file)
self.en_file = self.en(text='snowflake.py', width=5)
self.endrow()
</code></pre>
<p>The first argument torowis a list of weights that determines how extra space is allocated<br>
between widgets. The list[0,1]means that all extra space is allocated to the second wid-<br>
get, which is the Entry. If you run this code and resize the window, you will see that the<br>
Entry grows and the Button doesn’t.</p>
<p>The optionpady“pads” this row in theydirection, adding 30 pixels of space above and<br>
below.</p>
<p><strong>19.7. Menus and Callables 185</strong></p>
<p>endrowends this row of widgets, so subsequent widgets are packed in the column Frame.<br>
Gui.pykeeps a stack of Frames:</p>
<ul>
<li>When you userow,colorgrto create a Frame, it goes on top of the stack and becomes<br>
the current Frame.</li>
<li>When you useendrow,endcolorendgrto close a Frame, it gets popped off the stack<br>
and the previous Frame on the stack becomes the current Frame.</li>
</ul>
<p>The methodrun_filereads the contents of the Entry, uses it as a filename, reads the con-<br>
tents and passes it torun_code.self.interis an Interpreter object that knows how to take<br>
a string and execute it as Python code.</p>
<pre><code>def run_file(self):
filename = self.en_file.get()
fp = open(filename)
source = fp.read()
self.inter.run_code(source, filename)
</code></pre>
<p>The last two widgets are a Text widget and a Button:</p>
<pre><code>self.te_code = self.te(width=25, height=10)
self.te_code.insert(END, 'world.clear()\n')
self.te_code.insert(END, 'bob = Turtle(world)\n')
</code></pre>
<pre><code>self.bu(text='Run code', command=self.run_text)
</code></pre>
<p>run_textis similar torun_fileexcept that it takes the code from the Text widget instead<br>
of from a file:</p>
<pre><code>def run_text(self):
source = self.te_code.get(1.0, END)
self.inter.run_code(source, '&lt;user-provided code&gt;')
</code></pre>
<p>Unfortunately, the details of widget layout are different in other languages, and in different<br>
Python modules. Tkinter alone provides three different mechanisms for arranging widgets.<br>
These mechanisms are called <strong>geometry managers</strong>. The one I demonstrated in this section<br>
is the “grid” geometry manager; the others are called “pack” and “place”.</p>
<p>Fortunately, most of the concepts in this section apply to other GUI modules and other<br>
languages.</p>
<h3 id="menus-and-callables">19.7 Menus and Callables</h3>
<p>A Menubutton is a widget that looks like a button, but when pressed it pops up a menu.<br>
After the user selects an item, the menu disappears.</p>
<p>Here is code that creates a color selection Menubutton (you can download it fromhttp:<br>
<a href="//thinkpython.com/code/menubutton_demo.py">//thinkpython.com/code/menubutton_demo.py</a>):</p>
<p>g = Gui()<br>
<a href="http://g.la">g.la</a>(‘Select a color:’)<br>
colors = [‘red’,‘green’, ‘blue’]<br>
mb = g.mb(text=colors[0])</p>
<p><strong>186 Chapter 19. Case study: Tkinter</strong></p>
<p>mbcreates the Menubutton. Initially, the text on the button is the name of the default color.<br>
The following loop creates one menu item for each color:</p>
<p>for color in colors:<br>
g.mi(mb, text=color, command=Callable(set_color, color))</p>
<p>The first argument ofmiis the Menubutton these items are associated with.</p>
<p>Thecommandoption is a Callable object, which is something new. So far we have seen<br>
functions and bound methods used as callbacks, which works fine if you don’t have to<br>
pass any arguments to the function. Otherwise you have to construct a Callable object that<br>
contains a function, likeset_color, and its arguments, likecolor.</p>
<p>The Callable object stores a reference to the function and the arguments as attributes. Later,<br>
when the user clicks on a menu item, the callback calls the function and passes the stored<br>
arguments.</p>
<p>Here is whatset_colormight look like:</p>
<p>def set_color(color):<br>
mb.config(text=color)<br>
print color</p>
<p>When the user selects a menu item andset_coloris called, it configures the Menubutton<br>
to display the newly-selected color. It also print the color; if you try this example, you can<br>
confirm thatset_coloris called when you select an item (andnotcalled when you create<br>
the Callable object).</p>
<h3 id="binding">19.8 Binding</h3>
<p>A <strong>binding</strong> is an association between a widget, an event and a callback: when an event (like<br>
a button press) happens on a widget, the callback is invoked.</p>
<p>Many widgets have default bindings. For example, when you press a button, the default<br>
binding changes the relief of the button to make it look depressed. When you release the<br>
button, the binding restores the appearance of the button and invokes the callback specified<br>
with thecommandoption.</p>
<p>You can use thebindmethod to override these default bindings or to add new ones. For<br>
example, this code creates a binding for a canvas (you can download the code in this section<br>
fromhttp://thinkpython.com/code/draggable_demo.py):</p>
<p>ca.bind(’’, make_circle)</p>
<p>The first argument is an event string; this event is triggered when the user presses<br>
the left mouse button. Other mouse events includeButtonMotion,ButtonReleaseand<br>
Double-Button.</p>
<p>The second argument is an event handler. An event handler is a function or bound method,<br>
like a callback, but an important difference is that an event handler takes an Event object<br>
as a parameter. Here is an example:</p>
<p>def make_circle(event):<br>
pos = ca.canvas_coords([event.x, event.y])<br>
item = ca.circle(pos, 5, fill=‘red’)</p>
<p><strong>19.8. Binding 187</strong></p>
<p>The Event object contains information about the type of event and details like the coordi-<br>
nates of the mouse pointer. In this example the information we need is the location of the<br>
mouse click. These values are in “pixel coordinates,” which are defined by the underlying<br>
graphical system. The methodcanvas_coordstranslates them to “Canvas coordinates,”<br>
which are compatible with Canvas methods likecircle.</p>
<p>For Entry widgets, it is common to bind theevent, which is triggered when the<br>
user presses theReturnorEnterkey. For example, the following code creates a Button and<br>
an Entry.</p>
<p>bu = g.bu(‘Make text item:’, make_text)<br>
en = g.en()<br>
en.bind(’’, make_text)</p>
<p>make_textis called when the Button is pressed or when the user hitsReturnwhile typing<br>
in the Entry. To make this work, we need a function that can be called as a command (with<br>
no arguments) or as an event handler (with an Event as an argument):</p>
<p>def make_text(event=None):<br>
text = en.get()<br>
item = ca.text([0,0], text)</p>
<p>make_textgets the contents of the Entry and displays it as a Text item in the Canvas.</p>
<p>It is also possible to create bindings for Canvas items. The following is a class definition<br>
forDraggable, which is a child class ofItemthat provides bindings that implement drag-<br>
and-drop capability.</p>
<p>class Draggable(Item):</p>
<pre><code>def __init__(self, item):
self.canvas = item.canvas
self.tag = item.tag
self.bind('&lt;Button-3&gt;', self.select)
self.bind('&lt;B3-Motion&gt;', self.drag)
self.bind('&lt;Release-3&gt;', self.drop)
</code></pre>
<p>The init method takes an Item as a parameter. It copies the attributes of the Item and then<br>
creates bindings for three events: a button press, button motion, and button release.</p>
<p>The event handlerselectstores the coordinates of the current event and the original color<br>
of the item, then changes the color to yellow:</p>
<pre><code>def select(self, event):
self.dragx = event.x
self.dragy = event.y
</code></pre>
<pre><code>self.fill = self.cget('fill')
self.config(fill='yellow')
</code></pre>
<p>cgetstands for “get configuration;” it takes the name of an option as a string and returns<br>
the current value of that option.</p>
<p>dragcomputes how far the object has moved relative to the starting place, updates the<br>
stored coordinates, and then moves the item.</p>
<pre><code>def drag(self, event):
dx = event.x - self.dragx
</code></pre>
<p><strong>188 Chapter 19. Case study: Tkinter</strong></p>
<pre><code>dy = event.y - self.dragy
</code></pre>
<pre><code>self.dragx = event.x
self.dragy = event.y
</code></pre>
<pre><code>self.move(dx, dy)
</code></pre>
<p>This computation is done in pixel coordinates; there is no need to convert to Canvas coor-<br>
dinates.</p>
<p>Finally,droprestores the original color of the item:</p>
<pre><code>def drop(self, event):
self.config(fill=self.fill)
</code></pre>
<p>You can use theDraggableclass to add drag-and-drop capability to an existing item. For<br>
example, here is a modified version ofmake_circlethat usescircleto create an Item and<br>
Draggableto make it draggable:</p>
<p>def make_circle(event):<br>
pos = ca.canvas_coords([event.x, event.y])<br>
item = ca.circle(pos, 5, fill=‘red’)<br>
item = Draggable(item)</p>
<p>This example demonstrates one of the benefits of inheritance: you can modify the capa-<br>
bilities of a parent class without modifying its definition. This is particularly useful if you<br>
want to change behavior defined in a module you did not write.</p>
<h3 id="debugging-6">19.9 Debugging</h3>
<p>One of the challenges of GUI programming is keeping track of which things happen while<br>
the GUI is being built and which things happen later in response to user events.</p>
<p>For example, when you are setting up a callback, it is a common error to call the function<br>
rather than passing a reference to it:</p>
<p>def the_callback():<br>
print ‘Called.’</p>
<p>g.bu(text=‘This is wrong!’, command=the_callback())</p>
<p>If you run this code, you will see that it callsthe_callbackimmediately, andthencreates<br>
the button. When you press the button, it does nothing because the return value from<br>
the_callbackisNone. Usually you do not want to invoke a callback while you are setting<br>
up the GUI; it should only be invoked later in response to a user event.</p>
<p>Another challenge of GUI programming is that you don’t have control of the flow of exe-<br>
cution. Which parts of the program execute and their order are determined by user actions.<br>
That means that you have to design your program to work correctly for any possible se-<br>
quence of events.</p>
<p>For example, the GUI in Exercise 19.3 has two widgets: one creates a Circle item and the<br>
other changes the color of the Circle. If the user creates the circle and then changes its color,<br>
there’s no problem. But what if the user changes the color of a circle that doesn’t exist yet?<br>
Or creates more than one circle?</p>
<p><strong>19.10. Glossary 189</strong></p>
<p>As the number of widgets grows, it is increasingly difficult to imagine all possible se-<br>
quences of events. One way to manage this complexity is to encapsulate the state of the<br>
system in an object and then consider:</p>
<ul>
<li>What are the possible states? In the Circle example, we might consider two states:<br>
before and after the user creates the first circle.</li>
<li>In each state, what events can occur? In the example, the user can press either of the<br>
buttons, or quit.</li>
<li>For each state-event pair, what is the desired outcome? Since there are two states and<br>
two buttons, there are four state-event pairs to consider.</li>
<li>What can cause a transition from one state to another? In this case, there is a transition<br>
when the user creates the first circle.</li>
</ul>
<p>You might also find it useful to define, and check, invariants that should hold regardless of<br>
the sequence of events.</p>
<p>This approach to GUI programming can help you write correct code without taking the<br>
time to test every possible sequence of user events!</p>
<h3 id="glossary-6">19.10 Glossary</h3>
<p><strong>GUI:</strong> A graphical user interface.</p>
<p><strong>widget:</strong> One of the elements that makes up a GUI, including buttons, menus, text entry<br>
fields, etc.</p>
<p><strong>option:</strong> A value that controls the appearance or function of a widget.</p>
<p><strong>keyword argument:</strong> An argument that indicates the parameter name as part of the func-<br>
tion call.</p>
<p><strong>callback:</strong> A function associated with a widget that is called when the user performs an<br>
action.</p>
<p><strong>bound method:</strong> A method associated with a particular instance.</p>
<p><strong>event-driven programming:</strong> A style of programming in which the flow of execution is<br>
determined by user actions.</p>
<p><strong>event:</strong> A user action, like a mouse click or key press, that causes a GUI to respond.</p>
<p><strong>event loop:</strong> An infinite loop that waits for user actions and responds.</p>
<p><strong>item:</strong> A graphical element on a Canvas widget.</p>
<p><strong>bounding box:</strong> A rectangle that encloses a set of items, usually specified by two opposing<br>
corners.</p>
<p><strong>pack:</strong> To arrange and display the elements of a GUI.</p>
<p><strong>geometry manager:</strong> A system for packing widgets.</p>
<p><strong>binding:</strong> An association between a widget, an event, and an event handler. The event<br>
handler is called when the event occurs in the widget.</p>
<p><strong>190 Chapter 19. Case study: Tkinter</strong></p>
<h3 id="exercises-7">19.11 Exercises</h3>
<p><strong>Exercise 19.4.</strong> For this exercise, you will write an image viewer. Here is a simple example:</p>
<p>g = Gui()<br>
canvas = <a href="http://g.ca">g.ca</a>(width=300)<br>
photo = PhotoImage(file=‘danger.gif’)<br>
canvas.image([0,0], image=photo)<br>
g.mainloop()</p>
<p>PhotoImagereads a file and returns aPhotoImageobject that Tkinter can display.Canvas.image<br>
puts the image on the canvas, centered on the given coordinates. You can also put images on labels,<br>
buttons, and some other widgets:</p>
<p><a href="http://g.la">g.la</a>(image=photo)<br>
g.bu(image=photo)</p>
<p>PhotoImage can only handle a few image formats, like GIF and PPM, but we can use the Python<br>
Imaging Library (PIL) to read other files.</p>
<p>The name of the PIL module isImage, but Tkinter defines an object with the same name. To avoid<br>
the conflict, you can useimport…aslike this:</p>
<p>import Image as PIL<br>
import ImageTk</p>
<p>The first line importsImageand gives it the local namePIL. The second line importsImageTk,<br>
which can translate a PIL image into a Tkinter PhotoImage. Here’s an example:</p>
<p>image = PIL.open(‘allen.png’)<br>
photo2 = ImageTk.PhotoImage(image)<br>
<a href="http://g.la">g.la</a>(image=photo2)</p>
<ol>
<li>Downloadimage_demo.py,danger.gifandallen.pngfromhttp: // thinkpython.<br>
com/ code. Runimage_demo.py. You might have to installPILandImageTk. They<br>
are probably in your software repository, but if not you can get them fromhttp: //<br>
pythonware. com/ products/ pil.</li>
<li>Inimage_demo.pychange the name of the second PhotoImage fromphoto2tophotoand<br>
run the program again. You should see the second PhotoImage but not the first.<br>
The problem is that when you reassignphotoit overwrites the reference to the first PhotoIm-<br>
age, which then disappears. The same thing happens if you assign a PhotoImage to a local<br>
variable; it disappears when the function ends.<br>
To avoid this problem, you have to store a reference to each PhotoImage you want to keep. You<br>
can use a global variable, or store PhotoImages in a data structure or as an attribute of an<br>
object.<br>
This behavior can be frustrating, which is why I am warning you (and why the example image<br>
says “Danger!”).</li>
<li>Starting with this example, write a program that takes the name of a directory and loops<br>
through all the files, displaying any files that PIL recognizes as images. You can use atry<br>
statement to catch the files PIL doesn’t recognize.<br>
When the user clicks on the image, the program should display the next one.</li>
</ol>
<p><strong>19.11. Exercises 191</strong></p>
<ol start="4">
<li>PIL provides a variety of methods for manipulating images. You can read about them at<br>
<a href="http:">http:</a> // pythonware. com/ library/ pil/ handbook. As a challenge, choose a few of<br>
these methods and provide a GUI for applying them to images.</li>
</ol>
<p>Solution:http: // thinkpython. com/ code/ ImageBrowser. py.<br>
<strong>Exercise 19.5.</strong> A vector graphics editor is a program that allows users to draw and edit shapes on<br>
the screen and generate output files in vector graphics formats like Postscript and SVG.</p>
<p>Write a simple vector graphics editor using Tkinter. At a minimum, it should allow users to draw<br>
lines, circles and rectangles, and it should useCanvas.dumpto generate a Postscript description of<br>
the contents of the Canvas.</p>
<p>As a challenge, you could allow users to select and resize items on the Canvas.<br>
<strong>Exercise 19.6.</strong> Use Tkinter to write a basic web browser. It should have a Text widget where the<br>
user can enter a URL and a Canvas to display the contents of the page.</p>
<p>You can use theurllibmodule to download files (see Exercise 14.6) and theHTMLParsermodule<br>
to parse the HTML tags (seehttp: // docs. python. org/ 2/ library/ htmlparser. html).</p>
<p>At a minimum your browser should handle plain text and hyperlinks. As a challenge you could<br>
handle background colors, text formatting tags and images.</p>
<p><strong>192 Chapter 19. Case study: Tkinter</strong></p>
<h2 id="appendix-a">Appendix A</h2>
<h1 id="debugging-7">Debugging</h1>
<p>Different kinds of errors can occur in a program, and it is useful to distinguish among them<br>
in order to track them down more quickly:</p>
<ul>
<li>Syntax errors are produced by Python when it is translating the source code into<br>
byte code. They usually indicate that there is something wrong with the syntax of<br>
the program. Example: Omitting the colon at the end of adefstatement yields the<br>
somewhat redundant messageSyntaxError: invalid syntax.</li>
<li>Runtime errors are produced by the interpreter if something goes wrong while the<br>
program is running. Most runtime error messages include information about where<br>
the error occurred and what functions were executing. Example: An infinite recur-<br>
sion eventually causes the runtime error “maximum recursion depth exceeded.”</li>
<li>Semantic errors are problems with a program that runs without producing error mes-<br>
sages but doesn’t do the right thing. Example: An expression may not be evaluated<br>
in the order you expect, yielding an incorrect result.</li>
</ul>
<p>The first step in debugging is to figure out which kind of error you are dealing with. Al-<br>
though the following sections are organized by error type, some techniques are applicable<br>
in more than one situation.</p>
<h2 id="a.1-syntax-errors">A.1 Syntax errors</h2>
<p>Syntax errors are usually easy to fix once you figure out what they are. Unfortunately,<br>
the error messages are often not helpful. The most common messages areSyntaxError:<br>
invalid syntaxandSyntaxError: invalid token, neither of which is very informa-<br>
tive.</p>
<p>On the other hand, the message does tell you where in the program the problem occurred.<br>
Actually, it tells you where Python noticed a problem, which is not necessarily where the<br>
error is. Sometimes the error is prior to the location of the error message, often on the<br>
preceding line.</p>
<p><strong>194 Appendix A. Debugging</strong></p>
<p>If you are building the program incrementally, you should have a good idea about where<br>
the error is. It will be in the last line you added.</p>
<p>If you are copying code from a book, start by comparing your code to the book’s code<br>
very carefully. Check every character. At the same time, remember that the book might be<br>
wrong, so if you see something that looks like a syntax error, it might be.</p>
<p>Here are some ways to avoid the most common syntax errors:</p>
<ol>
<li>Make sure you are not using a Python keyword for a variable name.</li>
<li>Check that you have a colon at the end of the header of every compound statement,<br>
includingfor,while,if, anddefstatements.</li>
<li>Make sure that any strings in the code have matching quotation marks.</li>
<li>If you have multiline strings with triple quotes (single or double), make sure you<br>
have terminated the string properly. An unterminated string may cause aninvalid<br>
tokenerror at the end of your program, or it may treat the following part of the<br>
program as a string until it comes to the next string. In the second case, it might not<br>
produce an error message at all!</li>
<li>An unclosed opening operator—(,{, or[—makes Python continue with the next line<br>
as part of the current statement. Generally, an error occurs almost immediately in the<br>
next line.</li>
<li>Check for the classic=instead of==inside a conditional.</li>
<li>Check the indentation to make sure it lines up the way it is supposed to. Python<br>
can handle space and tabs, but if you mix them it can cause problems. The best way<br>
to avoid this problem is to use a text editor that knows about Python and generates<br>
consistent indentation.</li>
</ol>
<p>If nothing works, move on to the next section…</p>
<p><strong>A.1.1 I keep making changes and it makes no difference.</strong></p>
<p>If the interpreter says there is an error and you don’t see it, that might be because you and<br>
the interpreter are not looking at the same code. Check your programming environment to<br>
make sure that the program you are editing is the one Python is trying to run.</p>
<p>If you are not sure, try putting an obvious and deliberate syntax error at the beginning of<br>
the program. Now run it again. If the interpreter doesn’t find the new error, you are not<br>
running the new code.</p>
<p>There are a few likely culprits:</p>
<ul>
<li>You edited the file and forgot to save the changes before running it again. Some<br>
programming environments do this for you, but some don’t.</li>
<li>You changed the name of the file, but you are still running the old name.</li>
<li>Something in your development environment is configured incorrectly.</li>
</ul>
<p><strong>A.2. Runtime errors 195</strong></p>
<ul>
<li>If you are writing a module and usingimport, make sure you don’t give your module<br>
the same name as one of the standard Python modules.</li>
<li>If you are usingimportto read a module, remember that you have to restart the<br>
interpreter or usereloadto read a modified file. If you import the module again, it<br>
doesn’t do anything.</li>
</ul>
<p>If you get stuck and you can’t figure out what is going on, one approach is to start again<br>
with a new program like “Hello, World!,” and make sure you can get a known program to<br>
run. Then gradually add the pieces of the original program to the new one.</p>
<h3 id="a.2-runtime-errors">A.2 Runtime errors</h3>
<p>Once your program is syntactically correct, Python can compile it and at least start running<br>
it. What could possibly go wrong?</p>
<p><strong>A.2.1 My program does absolutely nothing.</strong></p>
<p>This problem is most common when your file consists of functions and classes but does<br>
not actually invoke anything to start execution. This may be intentional if you only plan to<br>
import this module to supply classes and functions.</p>
<p>If it is not intentional, make sure that you are invoking a function to start execution, or<br>
execute one from the interactive prompt. Also see the “Flow of Execution” section below.</p>
<p><strong>A.2.2 My program hangs.</strong></p>
<p>If a program stops and seems to be doing nothing, it is “hanging.” Often that means that it<br>
is caught in an infinite loop or infinite recursion.</p>
<ul>
<li>If there is a particular loop that you suspect is the problem, add aprintstatement<br>
immediately before the loop that says “entering the loop” and another immediately<br>
after that says “exiting the loop.”<br>
Run the program. If you get the first message and not the second, you’ve got an<br>
infinite loop. Go to the “Infinite Loop” section below.</li>
<li>Most of the time, an infinite recursion will cause the program to run for a while and<br>
then produce a “RuntimeError: Maximum recursion depth exceeded” error. If that<br>
happens, go to the “Infinite Recursion” section below.<br>
If you are not getting this error but you suspect there is a problem with a recursive<br>
method or function, you can still use the techniques in the “Infinite Recursion” sec-<br>
tion.</li>
<li>If neither of those steps works, start testing other loops and other recursive functions<br>
and methods.</li>
<li>If that doesn’t work, then it is possible that you don’t understand the flow of execu-<br>
tion in your program. Go to the “Flow of Execution” section below.</li>
</ul>
<p><strong>196 Appendix A. Debugging</strong></p>
<p><strong>Infinite Loop</strong></p>
<p>If you think you have an infinite loop and you think you know what loop is causing the<br>
problem, add aprintstatement at the end of the loop that prints the values of the variables<br>
in the condition and the value of the condition.</p>
<p>For example:</p>
<p>while x &gt; 0 and y &lt; 0 :</p>
<h1 id="do-something-to-x">do something to x</h1>
<h1 id="do-something-to-y">do something to y</h1>
<pre><code>print "x: ", x
print "y: ", y
print "condition: ", (x &gt; 0 and y &lt; 0)
</code></pre>
<p>Now when you run the program, you will see three lines of output for each time through<br>
the loop. The last time through the loop, the condition should befalse. If the loop keeps<br>
going, you will be able to see the values ofxandy, and you might figure out why they are<br>
not being updated correctly.</p>
<p><strong>Infinite Recursion</strong></p>
<p>Most of the time, an infinite recursion will cause the program to run for a while and then<br>
produce aMaximum recursion depth exceedederror.</p>
<p>If you suspect that a function or method is causing an infinite recursion, start by checking<br>
to make sure that there is a base case. In other words, there should be some condition that<br>
will cause the function or method to return without making a recursive invocation. If not,<br>
then you need to rethink the algorithm and identify a base case.</p>
<p>If there is a base case but the program doesn’t seem to be reaching it, add aprintstatement<br>
at the beginning of the function or method that prints the parameters. Now when you<br>
run the program, you will see a few lines of output every time the function or method is<br>
invoked, and you will see the parameters. If the parameters are not moving toward the<br>
base case, you will get some ideas about why not.</p>
<p><strong>Flow of Execution</strong></p>
<p>If you are not sure how the flow of execution is moving through your program, addprint<br>
statements to the beginning of each function with a message like “entering functionfoo,”<br>
wherefoois the name of the function.</p>
<p>Now when you run the program, it will print a trace of each function as it is invoked.</p>
<p><strong>A.2.3 When I run the program I get an exception.</strong></p>
<p>If something goes wrong during runtime, Python prints a message that includes the name<br>
of the exception, the line of the program where the problem occurred, and a traceback.</p>
<p>The traceback identifies the function that is currently running, and then the function that<br>
invoked it, and then the function that invokedthat, and so on. In other words, it traces the</p>
<p><strong>A.2. Runtime errors 197</strong></p>
<p>sequence of function invocations that got you to where you are. It also includes the line<br>
number in your file where each of these calls occurs.</p>
<p>The first step is to examine the place in the program where the error occurred and see if<br>
you can figure out what happened. These are some of the most common runtime errors:</p>
<p><strong>NameError:</strong> You are trying to use a variable that doesn’t exist in the current environment.<br>
Remember that local variables are local. You cannot refer to them from outside the<br>
function where they are defined.</p>
<p><strong>TypeError:</strong> There are several possible causes:</p>
<ul>
<li>You are trying to use a value improperly. Example: indexing a string, list, or<br>
tuple with something other than an integer.</li>
<li>There is a mismatch between the items in a format string and the items passed<br>
for conversion. This can happen if either the number of items does not match or<br>
an invalid conversion is called for.</li>
<li>You are passing the wrong number of arguments to a function or method. For<br>
methods, look at the method definition and check that the first parameter is<br>
self. Then look at the method invocation; make sure you are invoking the<br>
method on an object with the right type and providing the other arguments<br>
correctly.</li>
</ul>
<p><strong>KeyError:</strong> You are trying to access an element of a dictionary using a key that the dictio-<br>
nary does not contain.</p>
<p><strong>AttributeError:</strong> You are trying to access an attribute or method that does not exist. Check<br>
the spelling! You can usedirto list the attributes that do exist.<br>
If an AttributeError indicates that an object hasNoneType, that means that it isNone.<br>
One common cause is forgetting to return a value from a function; if you get to the<br>
end of a function without hitting areturnstatement, it returnsNone. Another com-<br>
mon cause is using the result from a list method, likesort, that returnsNone.</p>
<p><strong>IndexError:</strong> The index you are using to access a list, string, or tuple is greater than its<br>
length minus one. Immediately before the site of the error, add aprintstatement to<br>
display the value of the index and the length of the array. Is the array the right size?<br>
Is the index the right value?</p>
<p>The Python debugger (pdb) is useful for tracking down Exceptions because it allows you<br>
to examine the state of the program immediately before the error. You can read aboutpdb<br>
athttp://docs.python.org/2/library/pdb.html.</p>
<p><strong>A.2.4 I added so many</strong> print <strong>statements I get inundated with output.</strong></p>
<p>One of the problems with usingprintstatements for debugging is that you can end up<br>
buried in output. There are two ways to proceed: simplify the output or simplify the<br>
program.</p>
<p>To simplify the output, you can remove or comment outprintstatements that aren’t help-<br>
ing, or combine them, or format the output so it is easier to understand.</p>
<p><strong>198 Appendix A. Debugging</strong></p>
<p>To simplify the program, there are several things you can do. First, scale down the problem<br>
the program is working on. For example, if you are searching a list, search asmalllist. If<br>
the program takes input from the user, give it the simplest input that causes the problem.</p>
<p>Second, clean up the program. Remove dead code and reorganize the program to make<br>
it as easy to read as possible. For example, if you suspect that the problem is in a deeply<br>
nested part of the program, try rewriting that part with simpler structure. If you suspect a<br>
large function, try splitting it into smaller functions and testing them separately.</p>
<p>Often the process of finding the minimal test case leads you to the bug. If you find that<br>
a program works in one situation but not in another, that gives you a clue about what is<br>
going on.</p>
<p>Similarly, rewriting a piece of code can help you find subtle bugs. If you make a change<br>
that you think shouldn’t affect the program, and it does, that can tip you off.</p>
<h3 id="a.3-semantic-errors">A.3 Semantic errors</h3>
<p>In some ways, semantic errors are the hardest to debug, because the interpreter provides<br>
no information about what is wrong. Only you know what the program is supposed to do.</p>
<p>The first step is to make a connection between the program text and the behavior you are<br>
seeing. You need a hypothesis about what the program is actually doing. One of the things<br>
that makes that hard is that computers run so fast.</p>
<p>You will often wish that you could slow the program down to human speed, and with<br>
some debuggers you can. But the time it takes to insert a few well-placedprintstatements<br>
is often short compared to setting up the debugger, inserting and removing breakpoints,<br>
and “stepping” the program to where the error is occurring.</p>
<p><strong>A.3.1 My program doesn’t work.</strong></p>
<p>You should ask yourself these questions:</p>
<ul>
<li>Is there something the program was supposed to do but which doesn’t seem to be<br>
happening? Find the section of the code that performs that function and make sure<br>
it is executing when you think it should.</li>
<li>Is something happening that shouldn’t? Find code in your program that performs<br>
that function and see if it is executing when it shouldn’t.</li>
<li>Is a section of code producing an effect that is not what you expected? Make sure that<br>
you understand the code in question, especially if it involves invocations to functions<br>
or methods in other Python modules. Read the documentation for the functions you<br>
invoke. Try them out by writing simple test cases and checking the results.</li>
</ul>
<p>In order to program, you need to have a mental model of how programs work. If you write<br>
a program that doesn’t do what you expect, very often the problem is not in the program;<br>
it’s in your mental model.</p>
<p><strong>A.3. Semantic errors 199</strong></p>
<p>The best way to correct your mental model is to break the program into its components<br>
(usually the functions and methods) and test each component independently. Once you<br>
find the discrepancy between your model and reality, you can solve the problem.</p>
<p>Of course, you should be building and testing components as you develop the program.<br>
If you encounter a problem, there should be only a small amount of new code that is not<br>
known to be correct.</p>
<p><strong>A.3.2 I’ve got a big hairy expression and it doesn’t do what I expect.</strong></p>
<p>Writing complex expressions is fine as long as they are readable, but they can be hard to<br>
debug. It is often a good idea to break a complex expression into a series of assignments to<br>
temporary variables.</p>
<p>For example:</p>
<p>self.hands[i].addCard(self.hands[self.findNeighbor(i)].popCard())</p>
<p>This can be rewritten as:</p>
<p>neighbor = self.findNeighbor(i)<br>
pickedCard = self.hands[neighbor].popCard()<br>
self.hands[i].addCard(pickedCard)</p>
<p>The explicit version is easier to read because the variable names provide additional docu-<br>
mentation, and it is easier to debug because you can check the types of the intermediate<br>
variables and display their values.</p>
<p>Another problem that can occur with big expressions is that the order of evaluation may<br>
not be what you expect. For example, if you are translating the expression 2 x <em>π</em> into Python,<br>
you might write:</p>
<p>y = x / 2 * math.pi</p>
<p>That is not correct because multiplication and division have the same precedence and are<br>
evaluated from left to right. So this expression computesx <em>π</em> /2.</p>
<p>A good way to debug expressions is to add parentheses to make the order of evaluation<br>
explicit:</p>
<pre><code>y = x / (2 * math.pi)
</code></pre>
<p>Whenever you are not sure of the order of evaluation, use parentheses. Not only will the<br>
program be correct (in the sense of doing what you intended), it will also be more readable<br>
for other people who haven’t memorized the rules of precedence.</p>
<p><strong>A.3.3 I’ve got a function or method that doesn’t return what I expect.</strong></p>
<p>If you have areturnstatement with a complex expression, you don’t have a chance to print<br>
thereturnvalue before returning. Again, you can use a temporary variable. For example,<br>
instead of:</p>
<p>return self.hands[i].removeMatches()</p>
<p>you could write:</p>
<p>count = self.hands[i].removeMatches()<br>
return count</p>
<p>Now you have the opportunity to display the value ofcountbefore returning.</p>
<p><strong>200 Appendix A. Debugging</strong></p>
<p><strong>A.3.4 I’m really, really stuck and I need help.</strong></p>
<p>First, try getting away from the computer for a few minutes. Computers emit waves that<br>
affect the brain, causing these symptoms:</p>
<ul>
<li>Frustration and rage.</li>
<li>Superstitious beliefs (“the computer hates me”) and magical thinking (“the program<br>
only works when I wear my hat backward”).</li>
<li>Random walk programming (the attempt to program by writing every possible pro-<br>
gram and choosing the one that does the right thing).</li>
</ul>
<p>If you find yourself suffering from any of these symptoms, get up and go for a walk. When<br>
you are calm, think about the program. What is it doing? What are some possible causes<br>
of that behavior? When was the last time you had a working program, and what did you<br>
do next?</p>
<p>Sometimes it just takes time to find a bug. I often find bugs when I am away from the<br>
computer and let my mind wander. Some of the best places to find bugs are trains, showers,<br>
and in bed, just before you fall asleep.</p>
<p><strong>A.3.5 No, I really need help.</strong></p>
<p>It happens. Even the best programmers occasionally get stuck. Sometimes you work on a<br>
program so long that you can’t see the error. A fresh pair of eyes is just the thing.</p>
<p>Before you bring someone else in, make sure you are prepared. Your program should be as<br>
simple as possible, and you should be working on the smallest input that causes the error.<br>
You should haveprintstatements in the appropriate places (and the output they produce<br>
should be comprehensible). You should understand the problem well enough to describe<br>
it concisely.</p>
<p>When you bring someone in to help, be sure to give them the information they need:</p>
<ul>
<li>If there is an error message, what is it and what part of the program does it indicate?</li>
<li>What was the last thing you did before this error occurred? What were the last lines<br>
of code that you wrote, or what is the new test case that fails?</li>
<li>What have you tried so far, and what have you learned?</li>
</ul>
<p>When you find the bug, take a second to think about what you could have done to find it<br>
faster. Next time you see something similar, you will be able to find the bug more quickly.</p>
<p>Remember, the goal is not just to make the program work. The goal is to learn how to make<br>
the program work.</p>
<h2 id="appendix-b">Appendix B</h2>
<h1 id="analysis-of-algorithms">Analysis of Algorithms</h1>
<pre><code>This appendix is an edited excerpt fromThink Complexity, by Allen B. Downey,
also published by O’Reilly Media (2011). When you are done with this book,
you might want to move on to that one.
</code></pre>
<p><strong>Analysis of algorithms</strong> is a branch of computer science that studies the performance of<br>
algorithms, especially their run time and space requirements. See <a href="http://en.wikipedia.org/wiki/Analysis_of_algorithms">http://en.wikipedia.org/wiki/Analysis_of_algorithms</a> .</p>
<p>The practical goal of algorithm analysis is to predict the performance of different algorithms in order to guide design decisions.</p>
<p>During the 2008 United States Presidential Campaign, candidate Barack Obama was asked<br>
to perform an impromptu analysis when he visited Google. Chief executive Eric Schmidt<br>
jokingly asked him for “the most efficient way to sort a million 32-bit integers.” Obama<br>
had apparently been tipped off, because he quickly replied, “I think the bubble sort would<br>
be the wrong way to go.” Seehttp://www.youtube.com/watch?v=k4RRi_ntQc8.</p>
<p>This is true: bubble sort is conceptually simple but slow for large datasets. The an-<br>
swer Schmidt was probably looking for is “radix sort” (<a href="http://en.wikipedia.org/wiki/Radix_sort">http://en.wikipedia.org/wiki/Radix_sort</a>) .</p>
<p>The goal of algorithm analysis is to make meaningful comparisons between algorithms, but there are some problems:</p>
<ul>
<li>The relative performance of the algorithms might depend on characteristics of the<br>
hardware, so one algorithm might be faster on Machine A, another on Machine B.<br>
The general solution to this problem is to specify a <strong>machine model</strong> and analyze the<br>
number of steps, or operations, an algorithm requires under a given model.</li>
<li>Relative performance might depend on the details of the dataset. For example, some<br>
sorting algorithms run faster if the data are already partially sorted; other algorithms</li>
</ul>
<p>(^1) But if you get a question like this in an interview, I think a better answer is, “The fastest way to sort a million<br>
integers is to use whatever sort function is provided by the language I’m using. Its performance is good enough<br>
for the vast majority of applications, but if it turned out that my application was too slow, I would use a profiler<br>
to see where the time was being spent. If it looked like a faster sort algorithm would have a significant effect on<br>
performance, then I would look around for a good implementation of radix sort.”</p>
<p><strong>202 Appendix B. Analysis of Algorithms</strong></p>
<pre><code>run slower in this case. A common way to avoid this problem is to analyze the worst
case scenario. It is sometimes useful to analyze average case performance, but that’s
usually harder, and it might not be obvious what set of cases to average over.
</code></pre>
<ul>
<li>Relative performance also depends on the size of the problem. A sorting algorithm<br>
that is fast for small lists might be slow for long lists. The usual solution to this<br>
problem is to express run time (or number of operations) as a function of problem<br>
size, and to compare the functions <strong>asymptotically</strong> as the problem size increases.</li>
</ul>
<p>The good thing about this kind of comparison that it lends itself to simple classification of<br>
algorithms. For example, if I know that the run time of Algorithm A tends to be propor-<br>
tional to the size of the input,n, and Algorithm B tends to be proportional ton^2 , then I<br>
expect A to be faster than B for large values ofn.</p>
<p>This kind of analysis comes with some caveats, but we’ll get to that later.</p>
<h3 id="b.1-order-of-growth">B.1 Order of growth</h3>
<p>Suppose you have analyzed two algorithms and expressed their run times in terms of the<br>
size of the input: Algorithm A takes 100n+1 steps to solve a problem with sizen; Algo-<br>
rithm B takesn^2 +n+1 steps.</p>
<p>The following table shows the run time of these algorithms for different problem sizes:</p>
<pre><code>Input Run time of Run time of
size Algorithm A Algorithm B
10 1 001 111
100 10 001 10 101
1 000 100 001 1 001 001
10 000 1 000 001 &gt; 1010
</code></pre>
<p>Atn=10, Algorithm A looks pretty bad; it takes almost 10 times longer than Algorithm<br>
B. But forn=100 they are about the same, and for larger values A is much better.</p>
<p>The fundamental reason is that for large values ofn, any function that contains ann^2 term<br>
will grow faster than a function whose leading term isn. The <strong>leading term</strong> is the term with<br>
the highest exponent.</p>
<p>For Algorithm A, the leading term has a large coefficient, 100, which is why B does better<br>
than A for smalln. But regardless of the coefficients, there will always be some value ofn<br>
wherean^2 &gt;bn.</p>
<p>The same argument applies to the non-leading terms. Even if the run time of Algorithm A<br>
weren+1000000, it would still be better than Algorithm B for sufficiently largen.</p>
<p>In general, we expect an algorithm with a smaller leading term to be a better algorithm for<br>
large problems, but for smaller problems, there may be a <strong>crossover point</strong> where another<br>
algorithm is better. The location of the crossover point depends on the details of the algo-<br>
rithms, the inputs, and the hardware, so it is usually ignored for purposes of algorithmic<br>
analysis. But that doesn’t mean you can forget about it.</p>
<p>If two algorithms have the same leading order term, it is hard to say which is better; again,<br>
the answer depends on the details. So for algorithmic analysis, functions with the same<br>
leading term are considered equivalent, even if they have different coefficients.</p>
<p><strong>B.1. Order of growth 203</strong></p>
<p>An <strong>order of growth</strong> is a set of functions whose asymptotic growth behavior is considered<br>
equivalent. For example, 2n, 100nandn+1 belong to the same order of growth, which is<br>
writtenO(n)in <strong>Big-Oh notation</strong> and often called <strong>linear</strong> because every function in the set<br>
grows linearly withn.</p>
<p>All functions with the leading termn^2 belong toO(n^2 ); they are <strong>quadratic</strong> , which is a fancy<br>
word for functions with the leading termn^2.</p>
<p>The following table shows some of the orders of growth that appear most commonly in<br>
algorithmic analysis, in increasing order of badness.</p>
<pre><code>Order of Name
growth
O( 1 ) constant
O(logbn) logarithmic (for anyb)
O(n) linear
O(nlogbn) “en log en”
O(n^2 ) quadratic
O(n^3 ) cubic
O(cn) exponential (for anyc)
</code></pre>
<p>For the logarithmic terms, the base of the logarithm doesn’t matter; changing bases is the<br>
equivalent of multiplying by a constant, which doesn’t change the order of growth. Sim-<br>
ilarly, all exponential functions belong to the same order of growth regardless of the base<br>
of the exponent. Exponential functions grow very quickly, so exponential algorithms are<br>
only useful for small problems.<br>
<strong>Exercise B.1.</strong> Read the Wikipedia page on Big-Oh notation athttp: // en. wikipedia. org/<br>
wiki/ Big_ O_ notationand answer the following questions:</p>
<ol>
<li>What is the order of growth of n^3 +n^2? What about 1000000 n^3 +n^2? What about n^3 +<br>
1000000 n^2?</li>
<li>What is the order of growth of(n^2 +n)·(n+ 1 )? Before you start multiplying, remember<br>
that you only need the leading term.</li>
<li>If f is in O(g), for some unspecified function g, what can we say about a f+b?</li>
<li>If f 1 and f 2 are in O(g), what can we say about f 1 +f 2?</li>
<li>If f 1 is in O(g)and f 2 is in O(h), what can we say about f 1 +f 2?</li>
<li>If f 1 is in O(g)and f 2 is O(h), what can we say about f 1 ·f 2?</li>
</ol>
<p>Programmers who care about performance often find this kind of analysis hard to swal-<br>
low. They have a point: sometimes the coefficients and the non-leading terms make a<br>
real difference. Sometimes the details of the hardware, the programming language, and<br>
the characteristics of the input make a big difference. And for small problems asymptotic<br>
behavior is irrelevant.</p>
<p>But if you keep those caveats in mind, algorithmic analysis is a useful tool. At least for<br>
large problems, the “better” algorithms is usually better, and sometimes it ismuchbetter.<br>
The difference between two algorithms with the same order of growth is usually a constant<br>
factor, but the difference between a good algorithm and a bad algorithm is unbounded!</p>
<p><strong>204 Appendix B. Analysis of Algorithms</strong></p>
<h3 id="b.2-analysis-of-basic-python-operations">B.2 Analysis of basic Python operations</h3>
<p>Most arithmetic operations are constant time; multiplication usually takes longer than ad-<br>
dition and subtraction, and division takes even longer, but these run times don’t depend<br>
on the magnitude of the operands. Very large integers are an exception; in that case the run<br>
time increases with the number of digits.</p>
<p>Indexing operations—reading or writing elements in a sequence or dictionary—are also<br>
constant time, regardless of the size of the data structure.</p>
<p>Aforloop that traverses a sequence or dictionary is usually linear, as long as all of the<br>
operations in the body of the loop are constant time. For example, adding up the elements<br>
of a list is linear:</p>
<pre><code>total = 0
for x in t:
total += x
</code></pre>
<p>The built-in functionsumis also linear because it does the same thing, but it tends to be<br>
faster because it is a more efficient implementation; in the language of algorithmic analysis,<br>
it has a smaller leading coefficient.</p>
<p>If you use the same loop to “add” a list of strings, the run time is quadratic because string<br>
concatenation is linear.</p>
<p>The string methodjoinis usually faster because it is linear in the total length of the strings.</p>
<p>As a rule of thumb, if the body of a loop is inO(na)then the whole loop is inO(na+^1 ). The<br>
exception is if you can show that the loop exits after a constant number of iterations. If a<br>
loop runsktimes regardless ofn, then the loop is inO(na), even for largek.</p>
<p>Multiplying bykdoesn’t change the order of growth, but neither does dividing. So if the<br>
body of a loop is inO(na)and it runsn/ktimes, the loop is inO(na+^1 ), even for largek.</p>
<p>Most string and tuple operations are linear, except indexing andlen, which are constant<br>
time. The built-in functionsminandmaxare linear. The run-time of a slice operation is<br>
proportional to the length of the output, but independent of the size of the input.</p>
<p>All string methods are linear, but if the lengths of the strings are bounded by a constant—<br>
for example, operations on single characters—they are considered constant time.</p>
<p>Most list methods are linear, but there are some exceptions:</p>
<ul>
<li>Adding an element to the end of a list is constant time on average; when it runs<br>
out of room it occasionally gets copied to a bigger location, but the total time forn<br>
operations isO(n), so we say that the “amortized” time for one operation isO( 1 ).</li>
<li>Removing an element from the end of a list is constant time.</li>
<li>Sorting isO(nlogn).</li>
</ul>
<p>Most dictionary operations and methods are constant time, but there are some exceptions:</p>
<ul>
<li>The run time ofcopyis proportional to the number of elements, but not the size of<br>
the elements (it copies references, not the elements themselves).</li>
</ul>
<pre><code>B.3. Analysis of search algorithms 205
</code></pre>
<ul>
<li>The run time ofupdateis proportional to the size of the dictionary passed as a pa-<br>
rameter, not the dictionary being updated.</li>
<li>keys, values and items are linear because they return new lists; iterkeys,<br>
itervaluesanditeritemsare constant time because they return iterators. But if<br>
you loop through the iterators, the loop will be linear. Using the “iter” functions<br>
saves some overhead, but it doesn’t change the order of growth unless the number of<br>
items you access is bounded.</li>
</ul>
<pre><code>The performance of dictionaries is one of the minor miracles of computer science. We will
see how they work in Section B.4.
Exercise B.2. Read the Wikipedia page on sorting algorithms athttp: // en. wikipedia. org/
wiki/ Sorting_ algorithmand answer the following questions:
</code></pre>
<ol>
<li>What is a “comparison sort?” What is the best worst-case order of growth for a comparison<br>
sort? What is the best worst-case order of growth for any sort algorithm?</li>
<li>What is the order of growth of bubble sort, and why does Barack Obama think it is “the wrong<br>
way to go?”</li>
<li>What is the order of growth of radix sort? What preconditions do we need to use it?</li>
<li>What is a stable sort and why might it matter in practice?</li>
<li>What is the worst sorting algorithm (that has a name)?</li>
<li>What sort algorithm does the C library use? What sort algorithm does Python use? Are these<br>
algorithms stable? You might have to Google around to find these answers.</li>
<li>Many of the non-comparison sorts are linear, so why does does Python use an O(nlogn)<br>
comparison sort?</li>
</ol>
<h3 id="b.3-analysis-of-search-algorithms">B.3 Analysis of search algorithms</h3>
<pre><code>A search is an algorithm that takes a collection and a target item and determines whether
the target is in the collection, often returning the index of the target.
</code></pre>
<pre><code>The simplest search algorithm is a “linear search,” which traverses the items of the collec-
tion in order, stopping if it finds the target. In the worst case it has to traverse the entire
collection, so the run time is linear.
</code></pre>
<pre><code>Theinoperator for sequences uses a linear search; so do string methods likefindand
count.
</code></pre>
<p>If the elements of the sequence are in order, you can use a <strong>bisection search</strong> , which is<br>
O(logn). Bisection search is similar to the algorithm you probably use to look a word<br>
up in a dictionary (a real dictionary, not the data structure). Instead of starting at the be-<br>
ginning and checking each item in order, you start with the item in the middle and check<br>
whether the word you are looking for comes before or after. If it comes before, then you<br>
search the first half of the sequence. Otherwise you search the second half. Either way, you<br>
cut the number of remaining items in half.</p>
<pre><code>If the sequence has 1,000,000 items, it will take about 20 steps to find the word or conclude
that it’s not there. So that’s about 50,000 times faster than a linear search.
</code></pre>
<p><strong>206 Appendix B. Analysis of Algorithms</strong></p>
<p><strong>Exercise B.3.</strong> Write a function calledbisectionthat takes a sorted list and a target value and<br>
returns the index of the value in the list, if it’s there, orNoneif it’s not.</p>
<p>Or you could read the documentation of thebisectmodule and use that!</p>
<p>Bisection search can be much faster than linear search, but it requires the sequence to be in<br>
order, which might require extra work.</p>
<p>There is another data structure, called a <strong>hashtable</strong> that is even faster—it can do a search<br>
in constant time—and it doesn’t require the items to be sorted. Python dictionaries are<br>
implemented using hashtables, which is why most dictionary operations, including thein<br>
operator, are constant time.</p>
<h3 id="b.4-hashtables">B.4 Hashtables</h3>
<p>To explain how hashtables work and why their performance is so good, I start with a simple<br>
implementation of a map and gradually improve it until it’s a hashtable.</p>
<p>I use Python to demonstrate these implementations, but in real life you wouldn’t write<br>
code like this in Python; you would just use a dictionary! So for the rest of this chapter, you<br>
have to imagine that dictionaries don’t exist and you want to implement a data structure<br>
that maps from keys to values. The operations you have to implement are:</p>
<p>add(k, v) <strong>:</strong> Add a new item that maps from keykto valuev. With a Python dictionary,d,<br>
this operation is writtend[k] = v.</p>
<p>get(target) <strong>:</strong> Look up and return the value that corresponds to keytarget. With a Python<br>
dictionary,d, this operation is writtend[target]ord.get(target).</p>
<p>For now, I assume that each key only appears once. The simplest implementation of this<br>
interface uses a list of tuples, where each tuple is a key-value pair.</p>
<p>class LinearMap(object):</p>
<pre><code>def __init__(self):
self.items = []
</code></pre>
<pre><code>def add(self, k, v):
self.items.append((k, v))
</code></pre>
<pre><code>def get(self, k):
for key, val in self.items:
if key == k:
return val
raise KeyError
</code></pre>
<p>addappends a key-value tuple to the list of items, which takes constant time.</p>
<p>getuses aforloop to search the list: if it finds the target key it returns the corresponding<br>
value; otherwise it raises aKeyError. Sogetis linear.</p>
<p>An alternative is to keep the list sorted by key. Thengetcould use a bisection search,<br>
which isO(logn). But inserting a new item in the middle of a list is linear, so this might</p>
<p><strong>B.4. Hashtables 207</strong></p>
<p>not be the best option. There are other data structures (see <a href="http://en.wikipedia.org/wiki/Red-">http://en.wikipedia.org/wiki/Red-</a> black_tree) that can implement add and getin log time, but that’s still not as good as constant time, so let’s move on.</p>
<p>One way to improveLinearMapis to break the list of key-value pairs into smaller lists.<br>
Here’s an implementation calledBetterMap, which is a list of 100 LinearMaps. As we’ll<br>
see in a second, the order of growth forgetis still linear, butBetterMapis a step on the<br>
path toward hashtables:</p>
<p>class BetterMap(object):</p>
<pre><code>def __init__(self, n=100):
self.maps = []
for i in range(n):
self.maps.append(LinearMap())
</code></pre>
<pre><code>def find_map(self, k):
index = hash(k) % len(self.maps)
return self.maps[index]
</code></pre>
<pre><code>def add(self, k, v):
m = self.find_map(k)
m.add(k, v)
</code></pre>
<pre><code>def get(self, k):
m = self.find_map(k)
return m.get(k)
</code></pre>
<p>__init__makes a list ofn LinearMaps.</p>
<p>find_mapis used byaddandgetto figure out which map to put the new item in, or which<br>
map to search.</p>
<p>find_mapuses the built-in functionhash, which takes almost any Python object and returns<br>
an integer. A limitation of this implementation is that it only works with hashable keys.<br>
Mutable types like lists and dictionaries are unhashable.</p>
<p>Hashable objects that are considered equal return the same hash value, but the converse is<br>
not necessarily true: two different objects can return the same hash value.</p>
<p>find_mapuses the modulus operator to wrap the hash values into the range from 0 to<br>
len(self.maps), so the result is a legal index into the list. Of course, this means that many<br>
different hash values will wrap onto the same index. But if the hash function spreads things<br>
out pretty evenly (which is what hash functions are designed to do), then we expectn/100<br>
items per LinearMap.</p>
<p>Since the run time ofLinearMap.getis proportional to the number of items, we expect<br>
BetterMap to be about 100 times faster than LinearMap. The order of growth is still linear,<br>
but the leading coefficient is smaller. That’s nice, but still not as good as a hashtable.</p>
<p>Here (finally) is the crucial idea that makes hashtables fast: if you can keep the maximum<br>
length of the LinearMaps bounded,LinearMap.getis constant time. All you have to do is<br>
keep track of the number of items and when the number of items per LinearMap exceeds<br>
a threshold, resize the hashtable by adding more LinearMaps.</p>
<p>Here is an implementation of a hashtable:</p>
<p><strong>208 Appendix B. Analysis of Algorithms</strong></p>
<p>class HashMap(object):</p>
<pre><code>def __init__(self):
self.maps = BetterMap(2)
self.num = 0
</code></pre>
<pre><code>def get(self, k):
return self.maps.get(k)
</code></pre>
<pre><code>def add(self, k, v):
if self.num == len(self.maps.maps):
self.resize()
</code></pre>
<pre><code>self.maps.add(k, v)
self.num += 1
</code></pre>
<pre><code>def resize(self):
new_maps = BetterMap(self.num * 2)
</code></pre>
<pre><code>for m in self.maps.maps:
for k, v in m.items:
new_maps.add(k, v)
</code></pre>
<pre><code>self.maps = new_maps
</code></pre>
<p>EachHashMapcontains aBetterMap;__init__starts with just 2 LinearMaps and initializes<br>
num, which keeps track of the number of items.</p>
<p>getjust dispatches toBetterMap. The real work happens inadd, which checks the number<br>
of items and the size of theBetterMap: if they are equal, the average number of items per<br>
LinearMap is 1, so it callsresize.</p>
<p>resizemake a newBetterMap, twice as big as the previous one, and then “rehashes” the<br>
items from the old map to the new.</p>
<p>Rehashing is necessary because changing the number of LinearMaps changes the denom-<br>
inator of the modulus operator infind_map. That means that some objects that used to<br>
wrap into the same LinearMap will get split up (which is what we wanted, right?).</p>
<p>Rehashing is linear, soresizeis linear, which might seem bad, since I promised thatadd<br>
would be constant time. But remember that we don’t have to resize every time, soaddis<br>
usually constant time and only occasionally linear. The total amount of work to runaddn<br>
times is proportional ton, so the average time of eachaddis constant time!</p>
<p>To see how this works, think about starting with an empty HashTable and adding a se-<br>
quence of items. We start with 2 LinearMaps, so the first 2 adds are fast (no resizing re-<br>
quired). Let’s say that they take one unit of work each. The next add requires a resize, so<br>
we have to rehash the first two items (let’s call that 2 more units of work) and then add the<br>
third item (one more unit). Adding the next item costs 1 unit, so the total so far is 6 units<br>
of work for 4 items.</p>
<p>The nextaddcosts 5 units, but the next three are only one unit each, so the total is 14 units<br>
for the first 8 adds.</p>
<p><strong>B.4. Hashtables 209</strong></p>
<pre><code>Figure B.1: The cost of a hashtable add.
</code></pre>
<p>The nextaddcosts 9 units, but then we can add 7 more before the next resize, so the total is<br>
30 units for the first 16 adds.</p>
<p>After 32 adds, the total cost is 62 units, and I hope you are starting to see a pattern. Aftern<br>
adds, wherenis a power of two, the total cost is 2n−2 units, so the average work per add<br>
is a little less than 2 units. Whennis a power of two, that’s the best case; for other values of<br>
nthe average work is a little higher, but that’s not important. The important thing is that it<br>
isO( 1 ).</p>
<p>Figure B.1 shows how this works graphically. Each block represents a unit of work. The<br>
columns show the total work for each add in order from left to right: the first twoaddscost<br>
1 units, the third costs 3 units, etc.</p>
<p>The extra work of rehashing appears as a sequence of increasingly tall towers with increas-<br>
ing space between them. Now if you knock over the towers, amortizing the cost of resizing<br>
over all adds, you can see graphically that the total cost afternadds is 2n−2.</p>
<p>An important feature of this algorithm is that when we resize the HashTable it grows<br>
geometrically; that is, we multiply the size by a constant. If you increase the size<br>
arithmetically—adding a fixed number each time—the average time peraddis linear.</p>
<p>You can download my implementation of HashMap from <a href="http://thinkpython/code/Map.py">http://thinkpython/code/Map.py</a>, but remember that there is no reason to use it; if you want a map, just use a Python dictionary.</p>
<p><strong>210  Appendix B. Analysis of Algorithms</strong></p>
<h2 id="appendix-c">Appendix C</h2>
<h1 id="lumpy">Lumpy</h1>
<p>Throughout the book, I have used diagrams to represent the state of running programs.</p>
<p>In Section 2.2, we used a state diagram to show the names and values of variables. In<br>
Section 3.10 I introduced a stack diagram, which shows one frame for each function call.<br>
Each frame shows the parameters and local variables for the function or method. Stack<br>
diagrams for recursive functions appear in Section 5.9 and Section 6.5.</p>
<p>Section 10.2 shows what a list looks like in a state diagram, Section 11.4 shows what a<br>
dictionary looks like, and Section 12.6 shows two ways to represent tuples.</p>
<p>Section 15.2 introduces object diagrams, which show the state of an object’s attributes, and<br>
their attributes, and so on. Section 15.3 has object diagrams for Rectangles and their em-<br>
bedded Points. Section 16.1 shows the state of a Time object. Section 18.2 has a diagram<br>
that includes a class object and an instance, each with their own attributes.</p>
<p>Finally, Section 18.8 introduces class diagrams, which show the classes that make up a<br>
program and the relationships between them.</p>
<p>These diagrams are based on the Unified Modeling Language (UML), which is a stan-<br>
dardized graphical language used by software engineers to communicate about program<br>
design, especially for object-oriented programs.</p>
<p>UML is a rich language with many kinds of diagrams that represent many kinds of rela-<br>
tionship between objects and classes. What I presented in this book is a small subset of the<br>
language, but it is the subset most commonly used in practice.</p>
<p>The purpose of this appendix is to review the diagrams presented in the previous chapters,<br>
and to introduce Lumpy. Lumpy, which stands for “UML in Python,” with some of the<br>
letters rearranged, is part of Swampy, which you already installed if you worked on the<br>
case study in Chapter 4 or Chapter 19, or if you did Exercise 15.4,</p>
<p>Lumpy uses Python’sinspectmodule to examine the state of a running program and<br>
generate object diagrams (including stack diagrams) and class diagrams.</p>
<h2 id="c.1-state-diagram">C.1 State diagram</h2>
<p>Here’s an example that uses Lumpy to generate a state diagram.</p>
<p><strong>212 Appendix C. Lumpy</strong></p>
<pre><code>n 17
</code></pre>
<pre><code>message 'And now for something complete'
</code></pre>
<pre><code>pi 3.14159265359
</code></pre>
<pre><code>&lt;module&gt;
</code></pre>
<pre><code>Figure C.1: State diagram generated by Lumpy.
</code></pre>
<pre><code>&lt;module&gt; countdownn 2 countdownn 1 countdownn 0
</code></pre>
<pre><code>Figure C.2: Stack diagram.
</code></pre>
<p>from swampy.Lumpy import Lumpy</p>
<p>lumpy = Lumpy()<br>
lumpy.make_reference()</p>
<p>message = ‘And now for something completely different’<br>
n = 17<br>
pi = 3.1415926535897932</p>
<p>lumpy.object_diagram()</p>
<p>The first line imports the Lumpy class fromswampy.Lumpy. If you don’t have Swampy<br>
installed as a package, make sure the Swampy files are in Python’s search path and use<br>
thisimportstatement instead:</p>
<p>from Lumpy import Lumpy</p>
<p>The next lines create aLumpyobject and make a “reference” point, which means that Lumpy<br>
records the objects that have been defined so far.</p>
<p>Next we define new variables and invokeobject_diagram, which draws the objects that<br>
have been defined since the reference point, in this casemessage,nandpi.</p>
<p>Figure C.1 shows the result. The graphical style is different from what I showed earlier; for<br>
example, each reference is represented by a circle next to the variable name and a line to<br>
the value. And long strings are truncated. But the information conveyed by the diagram is<br>
the same.</p>
<p>The variable names are in a frame labeled, which indicates that these are module-<br>
level variables, also known as global.</p>
<p>You can download this example fromhttp://thinkpython.com/code/lumpy_demo1.py.<br>
Try adding some additional assignments and see what the diagram looks like.</p>
<h3 id="c.2-stack-diagram">C.2 Stack diagram</h3>
<p>Here’s an example that uses <strong>Lumpy</strong> to generate a stack diagram. You can download it from <a href="http://thinkpython.com/code/lumpy_demo2.py">http://thinkpython.com/code/lumpy_demo2.py</a></p>
<p><strong>C.3. Object diagrams 213</strong></p>
<pre><code>cheeses 0 'Cheddar'
</code></pre>
<pre><code>1 'Edam'
</code></pre>
<pre><code>2 'Gouda'
</code></pre>
<pre><code>list
</code></pre>
<pre><code>numbers 0 17
</code></pre>
<pre><code>1 123
</code></pre>
<pre><code>list
</code></pre>
<pre><code>empty list
</code></pre>
<pre><code>&lt;module&gt;
</code></pre>
<pre><code>Figure C.3: Object diagram.
</code></pre>
<pre class=" language-python"><code class="prism  language-python"><span class="token keyword">from</span> swampy<span class="token punctuation">.</span>Lumpy <span class="token keyword">import</span> Lumpy

<span class="token keyword">def</span> <span class="token function">countdown</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token keyword">if</span> n <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">:</span>
<span class="token keyword">print</span> <span class="token string">'Blastoff!'</span>
lumpy<span class="token punctuation">.</span>object_diagram<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">else</span><span class="token punctuation">:</span>
<span class="token keyword">print</span> n
countdown<span class="token punctuation">(</span>n<span class="token number">-1</span><span class="token punctuation">)</span>

lumpy <span class="token operator">=</span> Lumpy<span class="token punctuation">(</span><span class="token punctuation">)</span>
lumpy<span class="token punctuation">.</span>make_reference<span class="token punctuation">(</span><span class="token punctuation">)</span>
countdown<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>
</code></pre>
<p>Figure C.2 shows the result. Each frame is represented with a box that has the function’s name outside and variables inside. Since this function is recursive, there is one frame for each level of recursion.</p>
<p>Remember that a stack diagram shows the state of the program at a particular point in its execution. To get the diagram you want, sometimes you have to think about where to invoke object_diagram.</p>
<p>In this case I invokeobject_diagramafter executing the base case of the recursion; that way the stack diagram shows each level of the recursion. You can call <code>object_diagram</code>  more than once to get a series of snapshots of the program’s execution.</p>
<h3 id="c.3-object-diagrams">C.3 Object diagrams</h3>
<p>This example generates an object diagram showing the lists from Section 10.1. You can download it from <a href="http://thinkpython.com/code/lumpy_demo3.py">http://thinkpython.com/code/lumpy_demo3.py</a>.</p>
<pre class=" language-python"><code class="prism  language-python"><span class="token keyword">from</span> swampy<span class="token punctuation">.</span>Lumpy <span class="token keyword">import</span> Lumpy

lumpy <span class="token operator">=</span> Lumpy<span class="token punctuation">(</span><span class="token punctuation">)</span>
lumpy<span class="token punctuation">.</span>make_reference<span class="token punctuation">(</span><span class="token punctuation">)</span>

cheeses <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'Cheddar'</span><span class="token punctuation">,</span> <span class="token string">'Edam'</span><span class="token punctuation">,</span><span class="token string">'Gouda'</span><span class="token punctuation">]</span>
</code></pre>
<p><strong>214 Appendix C. Lumpy</strong></p>
<pre><code>inverse 1 0 'a'
</code></pre>
<pre><code>1 'p'
</code></pre>
<pre><code>2 't'
</code></pre>
<pre><code>3 'o'
</code></pre>
<pre><code>list
</code></pre>
<pre><code>2 0 'r'
</code></pre>
<pre><code>list
</code></pre>
<pre><code>dict
</code></pre>
<pre><code>hist 'a' 1
</code></pre>
<pre><code>'p' 1
</code></pre>
<pre><code>'r' 2
</code></pre>
<pre><code>'t' 1
</code></pre>
<pre><code>'o' 1
</code></pre>
<pre><code>dict
</code></pre>
<pre><code>&lt;module&gt;
</code></pre>
<pre><code>Figure C.4: Object diagram.
</code></pre>
<p>numbers = [17, 123]<br>
empty = []</p>
<p>lumpy.object_diagram()</p>
<p>Figure C.3 shows the result. Lists are represented by a box that shows the indices mapping<br>
to the elements. This representation is slightly misleading, since indices are not actually<br>
part of the list, but I think they make the diagram easier to read. The empty list is repre-<br>
sented by an empty box.</p>
<p>And here’s an example showing the dictionaries from Section 11.4. You can download it<br>
fromhttp://thinkpython.com/code/lumpy_demo4.py.</p>
<p>from swampy.Lumpy import Lumpy</p>
<p>lumpy = Lumpy()<br>
lumpy.make_reference()</p>
<p>hist = histogram(‘parrot’)<br>
inverse = invert_dict(hist)</p>
<p>lumpy.object_diagram()</p>
<p>Figure C.4 shows the result.histis a dictionary that maps from characters (single-letter<br>
strings) to integers;inversemaps from integers to lists of strings.</p>
<p>This example generates an object diagram for Point and Rectangle objects, as in Sec-<br>
tion 15.6. You can download it fromhttp://thinkpython.com/code/lumpy_demo5.py.</p>
<p>import copy<br>
from swampy.Lumpy import Lumpy</p>
<p><strong>C.4. Function and class objects 215</strong></p>
<pre><code>box width 100.0
</code></pre>
<pre><code>corner y 0.0
</code></pre>
<pre><code>x 0.0
</code></pre>
<pre><code>Point
</code></pre>
<pre><code>height 200.0
</code></pre>
<pre><code>Rectangle
</code></pre>
<pre><code>box2
</code></pre>
<pre><code>width 100.0
</code></pre>
<pre><code>height 200.0
</code></pre>
<pre><code>corner
</code></pre>
<pre><code>Rectangle
</code></pre>
<pre><code>&lt;module&gt;
</code></pre>
<pre><code>Figure C.5: Object diagram.
</code></pre>
<pre><code>Point __name__ 'Point'
</code></pre>
<pre><code>type
</code></pre>
<pre><code>instantiate __name__ 'instantiate'
</code></pre>
<pre><code>function
</code></pre>
<pre><code>Rectangle __name__ 'Rectangle'
</code></pre>
<pre><code>type
</code></pre>
<pre><code>&lt;module&gt;
obj
Point
</code></pre>
<pre><code>constructor
</code></pre>
<pre><code>instantiate
</code></pre>
<pre><code>Figure C.6: Object diagram.
</code></pre>
<p>lumpy = Lumpy()<br>
lumpy.make_reference()</p>
<p>box = Rectangle()<br>
box.width = 100.0<br>
box.height = 200.0<br>
box.corner = Point()<br>
box.corner.x = 0.0<br>
box.corner.y = 0.0</p>
<p>box2 = copy.copy(box)</p>
<p>lumpy.object_diagram()</p>
<p>Figure C.5 shows the result.copy.copymake a shallow copy, soboxandbox2have their<br>
ownwidthandheight, but they share the same embedded Point object. This kind of<br>
sharing is usually fine with immutable objects, but with mutable types, it is highly error-<br>
prone.</p>
<h3 id="c.4-function-and-class-objects">C.4 Function and class objects</h3>
<p>When I use Lumpy to make object diagrams, I usually define the functions and classes<br>
before I make the reference point. That way, function and class objects don’t appear in the<br>
diagram.</p>
<p><strong>216 Appendix C. Lumpy</strong></p>
<pre><code>object Rectangle
corner
height
width
</code></pre>
<pre><code>Point
x
y
</code></pre>
<pre><code>Figure C.7: Class diagram.
</code></pre>
<p>But if you are passing functions and classes as parameters, you might want them to appear.<br>
This example shows what that looks like; you can download it fromhttp://thinkpython.<br>
com/code/lumpy_demo6.py.</p>
<p>import copy<br>
from swampy.Lumpy import Lumpy</p>
<p>lumpy = Lumpy()<br>
lumpy.make_reference()</p>
<p>class Point(object):<br>
“”“Represents a point in 2-D space.”""</p>
<p>class Rectangle(object):<br>
“”“Represents a rectangle.”""</p>
<p>def instantiate(constructor):<br>
“”“Instantiates a new object.”""<br>
obj = constructor()<br>
lumpy.object_diagram()<br>
return obj</p>
<p>point = instantiate(Point)</p>
<p>Figure C.6 shows the result. Since we invokeobject_diagraminside a function, we get<br>
a stack diagram with a frame for the module-level variables and for the invocation of<br>
instantiate.</p>
<p>At the module level,PointandRectanglerefer to class objects (which have typetype);<br>
instantiaterefers to a function object.</p>
<p>This diagram might clarify two points of common confusion: (1) the difference between the<br>
class object,Point, and the instance of Point,obj, and (2) the difference between the func-<br>
tion object created wheninstantiateis defined, and the frame created with it is called.</p>
<h3 id="c.5-class-diagrams">C.5 Class Diagrams</h3>
<p>Although I distinguish between state diagrams, stack diagrams and object diagrams, they<br>
are mostly the same thing: they show the state of a running program at a point in time.</p>
<p><strong>C.5. Class Diagrams 217</strong></p>
<pre><code>object Deck
__init__
__str__
add_card
move_cards
pop_card
remove_card
shuffle
sort
cards
</code></pre>
<pre><code>Hand
__init__
</code></pre>
<pre><code>PokerHand
has_flush
suit_hist
cards
label
</code></pre>
<pre><code>Card
__cmp__
__init__
__str__
rank_names
suit_names
rank
suit
</code></pre>
<pre><code>Figure C.8: Class diagram.
</code></pre>
<p>Class diagrams are different. They show the classes that make up a program and the re-<br>
lationships between them. They are timeless in the sense that they describe the program<br>
as a whole, not any particular point in time. For example, if an instance of Class A gener-<br>
ally contains a reference to an instance of Class B, we say there is a “HAS-A relationship”<br>
between those classes.</p>
<p>Here’s an example that shows a HAS-A relationship. You can download it fromhttp:<br>
<a href="//thinkpython.com/code/lumpy_demo7.py">//thinkpython.com/code/lumpy_demo7.py</a>.</p>
<p>from swampy.Lumpy import Lumpy</p>
<p>lumpy = Lumpy()<br>
lumpy.make_reference()</p>
<p>box = Rectangle()<br>
box.width = 100.0<br>
box.height = 200.0<br>
box.corner = Point()<br>
box.corner.x = 0.0<br>
box.corner.y = 0.0</p>
<p>lumpy.class_diagram()</p>
<p>Figure C.7 shows the result. Each class is represented with a box that contains the name of<br>
the class, any methods the class provides, any class variables, and any instance variables.<br>
In this example,RectangleandPointhave instance variables, but no methods or class<br>
variables.</p>
<p>The arrow fromRectangletoPointshows that Rectangles contain an embedded Point.<br>
In addition,RectangleandPointboth inherit fromobject, which is represented in the<br>
diagram with a triangle-headed arrow.</p>
<p><strong>218 Appendix C. Lumpy</strong></p>
<p>Here’s a more complex example using my solution to Exercise 18.6. You can download<br>
the code fromhttp://thinkpython.com/code/lumpy_demo8.py; you will also needhttp:<br>
<a href="//thinkpython.com/code/PokerHand.py">//thinkpython.com/code/PokerHand.py</a>.</p>
<p>from swampy.Lumpy import Lumpy</p>
<p>from PokerHand import *</p>
<p>lumpy = Lumpy()<br>
lumpy.make_reference()</p>
<p>deck = Deck()<br>
hand = PokerHand()<br>
deck.move_cards(hand, 7)</p>
<p>lumpy.class_diagram()</p>
<p>Figure C.8 shows the result.PokerHandinherits fromHand, which inherits fromDeck. Both<br>
DeckandPokerHandhave Cards.</p>
<p>This diagram does not show thatHandalso has cards, because in the program there are no<br>
instances of Hand. This example demonstrates a limitation of Lumpy; it only knows about<br>
the attributes and HAS-A relationships of objects that are instantiated.</p>

    </div>
  </div>
</body>

</html>
